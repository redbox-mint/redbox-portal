/* tslint:disable */
/* eslint-disable */
/**
 * RAID v2 API
 * This file is where all the endpoint paths are defined, it\'s the \"top level\' of the OpenAPI definition that links all the different files together. The `3.0` in the filename refers to this file being based on OpenAPI 3.0  as opposed to OpenAPI 3.1, which the tooling doesn\'t support yet. The `2.0.0` in the version field refers to the fact that there\'s already  a `1.0.0` used for the legacy RAiD application. Note that swagger ui doesn\'t currently work with our spec,  see https://github.com/swagger-api/swagger-ui/issues/7724 But the spec works fine with openapi-generator tooling. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: contact@raid.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {AccessType}
     * @memberof Access
     */
    'type': AccessType;
    /**
     * 
     * @type {AccessStatement}
     * @memberof Access
     */
    'statement'?: AccessStatement;
    /**
     * Date the embargo on access to the RAiD ends. Year
     * @type {string}
     * @memberof Access
     */
    'embargoExpiry'?: string;
}
/**
 * 
 * @export
 * @interface AccessStatement
 */
export interface AccessStatement {
    /**
     * 
     * @type {string}
     * @memberof AccessStatement
     */
    'text'?: string;
    /**
     * 
     * @type {Language}
     * @memberof AccessStatement
     */
    'language'?: Language;
}
/**
 * 
 * @export
 * @interface AccessType
 */
export interface AccessType {
    /**
     * 
     * @type {string}
     * @memberof AccessType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccessType
     */
    'schemaUri': string;
}
/**
 * 
 * @export
 * @interface AlternateIdentifier
 */
export interface AlternateIdentifier {
    /**
     * 
     * @type {string}
     * @memberof AlternateIdentifier
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlternateIdentifier
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AlternateUrl
 */
export interface AlternateUrl {
    /**
     * 
     * @type {string}
     * @memberof AlternateUrl
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ClosedRaid
 */
export interface ClosedRaid {
    /**
     * 
     * @type {Id}
     * @memberof ClosedRaid
     */
    'identifier'?: Id;
    /**
     * 
     * @type {Access}
     * @memberof ClosedRaid
     */
    'access'?: Access;
}
/**
 * 
 * @export
 * @interface Contributor
 */
export interface Contributor {
    /**
     * 
     * @type {string}
     * @memberof Contributor
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Contributor
     */
    'schemaUri': string;
    /**
     * 
     * @type {Array<ContributorPosition>}
     * @memberof Contributor
     */
    'position': Array<ContributorPosition>;
    /**
     * 
     * @type {Array<ContributorRole>}
     * @memberof Contributor
     */
    'role': Array<ContributorRole>;
    /**
     * 
     * @type {boolean}
     * @memberof Contributor
     */
    'leader'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Contributor
     */
    'contact'?: boolean;
}
/**
 * 
 * @export
 * @interface ContributorPosition
 */
export interface ContributorPosition {
    /**
     * 
     * @type {string}
     * @memberof ContributorPosition
     */
    'schemaUri': string;
    /**
     * 
     * @type {string}
     * @memberof ContributorPosition
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContributorPosition
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof ContributorPosition
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface ContributorRole
 */
export interface ContributorRole {
    /**
     * 
     * @type {string}
     * @memberof ContributorRole
     */
    'schemaUri': string;
    /**
     * 
     * @type {string}
     * @memberof ContributorRole
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Description
 */
export interface Description {
    /**
     * 
     * @type {string}
     * @memberof Description
     */
    'text': string;
    /**
     * 
     * @type {DescriptionType}
     * @memberof Description
     */
    'type': DescriptionType;
    /**
     * 
     * @type {Language}
     * @memberof Description
     */
    'language'?: Language;
}
/**
 * 
 * @export
 * @interface DescriptionType
 */
export interface DescriptionType {
    /**
     * 
     * @type {string}
     * @memberof DescriptionType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DescriptionType
     */
    'schemaUri': string;
}
/**
 * 
 * @export
 * @interface FailureResponse
 */
export interface FailureResponse {
    /**
     * 
     * @type {string}
     * @memberof FailureResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof FailureResponse
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof FailureResponse
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof FailureResponse
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof FailureResponse
     */
    'instance': string;
}
/**
 * 
 * @export
 * @interface Id
 */
export interface Id {
    /**
     * The identifier of the raid, e.g. https://raid.org.au/102.100.100/zzz
     * @type {string}
     * @memberof Id
     */
    'id': string;
    /**
     * The URI of the Identifier scheme. For example, https://raid.org 
     * @type {string}
     * @memberof Id
     */
    'schemaUri': string;
    /**
     * 
     * @type {RegistrationAgency}
     * @memberof Id
     */
    'registrationAgency': RegistrationAgency;
    /**
     * 
     * @type {Owner}
     * @memberof Id
     */
    'owner': Owner;
    /**
     * The URL for the raid via the minting raid agency system, e.g  https://raid.org.au/10378.1/1695863 
     * @type {string}
     * @memberof Id
     */
    'raidAgencyUrl'?: string;
    /**
     * The license under which the RAiD Metadata Record associated with this Identifier has been issued.
     * @type {string}
     * @memberof Id
     */
    'license': string;
    /**
     * The version of the resource. Read-only. Increments automatically on update.
     * @type {number}
     * @memberof Id
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'schemaUri': string;
}
/**
 * Metadata schema block containing the start and end date of the RAiD.
 * @export
 * @interface ModelDate
 */
export interface ModelDate {
    /**
     * 
     * @type {string}
     * @memberof ModelDate
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof ModelDate
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    'schemaUri': string;
    /**
     * 
     * @type {Array<OrganisationRole>}
     * @memberof Organisation
     */
    'role': Array<OrganisationRole>;
}
/**
 * 
 * @export
 * @interface OrganisationRole
 */
export interface OrganisationRole {
    /**
     * 
     * @type {string}
     * @memberof OrganisationRole
     */
    'schemaUri': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationRole
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationRole
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationRole
     */
    'endDate'?: string;
}
/**
 * The legal entity responsible for the RAiD; the ‘Owner’ of a RAiD. Analogous to a DataCite ‘Member’, has a  legal agreement with the Registration Agency. 
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'schemaUri': string;
    /**
     * The Service Point (SP) that requested the RAiD. Analogous to a DataCite ‘Repository’. SPs belong to an owner, RAiD owners can have multiple SPs, and SPs do not need to be legal entities. 
     * @type {number}
     * @memberof Owner
     */
    'servicePoint'?: number;
}
/**
 * 
 * @export
 * @interface RaidChange
 */
export interface RaidChange {
    /**
     * 
     * @type {string}
     * @memberof RaidChange
     */
    'handle'?: string;
    /**
     * 
     * @type {number}
     * @memberof RaidChange
     */
    'version'?: number;
    /**
     * A base64 encoded json patch (RFC 6902) representation of a change to the raid.
     * @type {string}
     * @memberof RaidChange
     */
    'diff'?: string;
    /**
     * A timestamp of the change
     * @type {string}
     * @memberof RaidChange
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface RaidCreateRequest
 */
export interface RaidCreateRequest {
    /**
     * 
     * @type {Id}
     * @memberof RaidCreateRequest
     */
    'identifier'?: Id;
    /**
     * 
     * @type {Array<Title>}
     * @memberof RaidCreateRequest
     */
    'title'?: Array<Title>;
    /**
     * 
     * @type {ModelDate}
     * @memberof RaidCreateRequest
     */
    'date'?: ModelDate;
    /**
     * 
     * @type {Array<Description>}
     * @memberof RaidCreateRequest
     */
    'description'?: Array<Description>;
    /**
     * 
     * @type {Access}
     * @memberof RaidCreateRequest
     */
    'access': Access;
    /**
     * 
     * @type {Array<AlternateUrl>}
     * @memberof RaidCreateRequest
     */
    'alternateUrl'?: Array<AlternateUrl>;
    /**
     * 
     * @type {Array<Contributor>}
     * @memberof RaidCreateRequest
     */
    'contributor'?: Array<Contributor>;
    /**
     * 
     * @type {Array<Organisation>}
     * @memberof RaidCreateRequest
     */
    'organisation'?: Array<Organisation>;
    /**
     * 
     * @type {Array<Subject>}
     * @memberof RaidCreateRequest
     */
    'subject'?: Array<Subject>;
    /**
     * 
     * @type {Array<RelatedRaid>}
     * @memberof RaidCreateRequest
     */
    'relatedRaid'?: Array<RelatedRaid>;
    /**
     * 
     * @type {Array<RelatedObject>}
     * @memberof RaidCreateRequest
     */
    'relatedObject'?: Array<RelatedObject>;
    /**
     * 
     * @type {Array<AlternateIdentifier>}
     * @memberof RaidCreateRequest
     */
    'alternateIdentifier'?: Array<AlternateIdentifier>;
    /**
     * 
     * @type {Array<SpatialCoverage>}
     * @memberof RaidCreateRequest
     */
    'spatialCoverage'?: Array<SpatialCoverage>;
    /**
     * 
     * @type {Array<TraditionalKnowledgeLabel>}
     * @memberof RaidCreateRequest
     */
    'traditionalKnowledgeLabel'?: Array<TraditionalKnowledgeLabel>;
}
/**
 * 
 * @export
 * @interface RaidDto
 */
export interface RaidDto {
    /**
     * 
     * @type {Id}
     * @memberof RaidDto
     */
    'identifier': Id;
    /**
     * 
     * @type {Array<Title>}
     * @memberof RaidDto
     */
    'title'?: Array<Title>;
    /**
     * 
     * @type {ModelDate}
     * @memberof RaidDto
     */
    'date'?: ModelDate;
    /**
     * 
     * @type {Array<Description>}
     * @memberof RaidDto
     */
    'description'?: Array<Description>;
    /**
     * 
     * @type {Access}
     * @memberof RaidDto
     */
    'access': Access;
    /**
     * 
     * @type {Array<AlternateUrl>}
     * @memberof RaidDto
     */
    'alternateUrl'?: Array<AlternateUrl>;
    /**
     * 
     * @type {Array<Contributor>}
     * @memberof RaidDto
     */
    'contributor'?: Array<Contributor>;
    /**
     * 
     * @type {Array<Organisation>}
     * @memberof RaidDto
     */
    'organisation'?: Array<Organisation>;
    /**
     * 
     * @type {Array<Subject>}
     * @memberof RaidDto
     */
    'subject'?: Array<Subject>;
    /**
     * 
     * @type {Array<RelatedRaid>}
     * @memberof RaidDto
     */
    'relatedRaid'?: Array<RelatedRaid>;
    /**
     * 
     * @type {Array<RelatedObject>}
     * @memberof RaidDto
     */
    'relatedObject'?: Array<RelatedObject>;
    /**
     * 
     * @type {Array<AlternateIdentifier>}
     * @memberof RaidDto
     */
    'alternateIdentifier'?: Array<AlternateIdentifier>;
    /**
     * 
     * @type {Array<SpatialCoverage>}
     * @memberof RaidDto
     */
    'spatialCoverage'?: Array<SpatialCoverage>;
    /**
     * 
     * @type {Array<TraditionalKnowledgeLabel>}
     * @memberof RaidDto
     */
    'traditionalKnowledgeLabel'?: Array<TraditionalKnowledgeLabel>;
}
/**
 * 
 * @export
 * @interface RaidUpdateRequest
 */
export interface RaidUpdateRequest {
    /**
     * 
     * @type {Id}
     * @memberof RaidUpdateRequest
     */
    'identifier': Id;
    /**
     * 
     * @type {Array<Title>}
     * @memberof RaidUpdateRequest
     */
    'title'?: Array<Title>;
    /**
     * 
     * @type {ModelDate}
     * @memberof RaidUpdateRequest
     */
    'date'?: ModelDate;
    /**
     * 
     * @type {Array<Description>}
     * @memberof RaidUpdateRequest
     */
    'description'?: Array<Description>;
    /**
     * 
     * @type {Access}
     * @memberof RaidUpdateRequest
     */
    'access': Access;
    /**
     * 
     * @type {Array<AlternateUrl>}
     * @memberof RaidUpdateRequest
     */
    'alternateUrl'?: Array<AlternateUrl>;
    /**
     * 
     * @type {Array<Contributor>}
     * @memberof RaidUpdateRequest
     */
    'contributor'?: Array<Contributor>;
    /**
     * 
     * @type {Array<Organisation>}
     * @memberof RaidUpdateRequest
     */
    'organisation'?: Array<Organisation>;
    /**
     * 
     * @type {Array<Subject>}
     * @memberof RaidUpdateRequest
     */
    'subject'?: Array<Subject>;
    /**
     * 
     * @type {Array<RelatedRaid>}
     * @memberof RaidUpdateRequest
     */
    'relatedRaid'?: Array<RelatedRaid>;
    /**
     * 
     * @type {Array<RelatedObject>}
     * @memberof RaidUpdateRequest
     */
    'relatedObject'?: Array<RelatedObject>;
    /**
     * 
     * @type {Array<AlternateIdentifier>}
     * @memberof RaidUpdateRequest
     */
    'alternateIdentifier'?: Array<AlternateIdentifier>;
    /**
     * 
     * @type {Array<SpatialCoverage>}
     * @memberof RaidUpdateRequest
     */
    'spatialCoverage'?: Array<SpatialCoverage>;
    /**
     * 
     * @type {Array<TraditionalKnowledgeLabel>}
     * @memberof RaidUpdateRequest
     */
    'traditionalKnowledgeLabel'?: Array<TraditionalKnowledgeLabel>;
}
/**
 * ROR that identifies the organisation that operates the raid registration agency software that minted this raid. 
 * @export
 * @interface RegistrationAgency
 */
export interface RegistrationAgency {
    /**
     * 
     * @type {string}
     * @memberof RegistrationAgency
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationAgency
     */
    'schemaUri': string;
}
/**
 * 
 * @export
 * @interface RelatedObject
 */
export interface RelatedObject {
    /**
     * 
     * @type {string}
     * @memberof RelatedObject
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RelatedObject
     */
    'schemaUri'?: string;
    /**
     * 
     * @type {RelatedObjectType}
     * @memberof RelatedObject
     */
    'type'?: RelatedObjectType;
    /**
     * 
     * @type {Array<RelatedObjectCategory>}
     * @memberof RelatedObject
     */
    'category'?: Array<RelatedObjectCategory>;
}
/**
 * 
 * @export
 * @interface RelatedObjectCategory
 */
export interface RelatedObjectCategory {
    /**
     * 
     * @type {string}
     * @memberof RelatedObjectCategory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RelatedObjectCategory
     */
    'schemaUri'?: string;
}
/**
 * 
 * @export
 * @interface RelatedObjectType
 */
export interface RelatedObjectType {
    /**
     * 
     * @type {string}
     * @memberof RelatedObjectType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RelatedObjectType
     */
    'schemaUri'?: string;
}
/**
 * 
 * @export
 * @interface RelatedRaid
 */
export interface RelatedRaid {
    /**
     * 
     * @type {string}
     * @memberof RelatedRaid
     */
    'id'?: string;
    /**
     * 
     * @type {RelatedRaidType}
     * @memberof RelatedRaid
     */
    'type'?: RelatedRaidType;
}
/**
 * 
 * @export
 * @interface RelatedRaidType
 */
export interface RelatedRaidType {
    /**
     * 
     * @type {string}
     * @memberof RelatedRaidType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RelatedRaidType
     */
    'schemaUri': string;
}
/**
 * data that any member of service-point and operators can see
 * @export
 * @interface ServicePoint
 */
export interface ServicePoint {
    /**
     * 
     * @type {number}
     * @memberof ServicePoint
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServicePoint
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServicePoint
     */
    'identifierOwner': string;
    /**
     * The Datacite repository id. This needs to be created in Fabrica.
     * @type {string}
     * @memberof ServicePoint
     */
    'repositoryId'?: string;
    /**
     * The prefix used in the handle when minting RAiDs. Assigned when the repository is created.
     * @type {string}
     * @memberof ServicePoint
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePoint
     */
    'searchContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePoint
     */
    'techEmail': string;
    /**
     * 
     * @type {string}
     * @memberof ServicePoint
     */
    'adminEmail': string;
    /**
     * 
     * @type {boolean}
     * @memberof ServicePoint
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServicePoint
     */
    'appWritesEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ServicePointCreateRequest
 */
export interface ServicePointCreateRequest {
    /**
     * The name of the service point
     * @type {string}
     * @memberof ServicePointCreateRequest
     */
    'name': string;
    /**
     * The email address of the person responsible for administering the service point.
     * @type {string}
     * @memberof ServicePointCreateRequest
     */
    'adminEmail'?: string;
    /**
     * The email address of a technical contact when using the API
     * @type {string}
     * @memberof ServicePointCreateRequest
     */
    'techEmail'?: string;
    /**
     * The PID of the institution that will own the RAiDs (currently only RORs are supported).
     * @type {string}
     * @memberof ServicePointCreateRequest
     */
    'identifierOwner': string;
    /**
     * The Datacite repository id. This needs to be created in Fabrica.
     * @type {string}
     * @memberof ServicePointCreateRequest
     */
    'repositoryId'?: string;
    /**
     * The prefix used in the handle when minting RAiDs. Assigned when the repository is created.
     * @type {string}
     * @memberof ServicePointCreateRequest
     */
    'prefix'?: string;
    /**
     * The password of the repository in Datacite.
     * @type {string}
     * @memberof ServicePointCreateRequest
     */
    'password'?: string;
    /**
     * Whether users are able to edit RAiDs in the in the app. This can cause conflicts when also creating/updating RAiDs through the API.
     * @type {boolean}
     * @memberof ServicePointCreateRequest
     */
    'appWritesEnabled'?: boolean;
    /**
     * Whether the service point is able to create or update RAiDs
     * @type {boolean}
     * @memberof ServicePointCreateRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ServicePointUpdateRequest
 */
export interface ServicePointUpdateRequest {
    /**
     * The name of the service point
     * @type {number}
     * @memberof ServicePointUpdateRequest
     */
    'id': number;
    /**
     * The name of the service point
     * @type {string}
     * @memberof ServicePointUpdateRequest
     */
    'name': string;
    /**
     * The email address of the person responsible for administering the service point.
     * @type {string}
     * @memberof ServicePointUpdateRequest
     */
    'adminEmail'?: string;
    /**
     * The email address of a technical contact when using the API
     * @type {string}
     * @memberof ServicePointUpdateRequest
     */
    'techEmail'?: string;
    /**
     * The PID of the institution that will own the RAiDs (currently only RORs are supported).
     * @type {string}
     * @memberof ServicePointUpdateRequest
     */
    'identifierOwner': string;
    /**
     * The Datacite repository id. This needs to be created in Fabrica.
     * @type {string}
     * @memberof ServicePointUpdateRequest
     */
    'repositoryId'?: string;
    /**
     * The prefix used in the handle when minting RAiDs. Assigned when the repository is created.
     * @type {string}
     * @memberof ServicePointUpdateRequest
     */
    'prefix'?: string;
    /**
     * The password of the repository in Datacite.
     * @type {string}
     * @memberof ServicePointUpdateRequest
     */
    'password'?: string;
    /**
     * Whether users are able to edit RAiDs in the in the app. This can cause conflicts when also creating/updating RAiDs through the API.
     * @type {boolean}
     * @memberof ServicePointUpdateRequest
     */
    'appWritesEnabled'?: boolean;
    /**
     * Whether the service point is able to create or update RAiDs
     * @type {boolean}
     * @memberof ServicePointUpdateRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface SpatialCoverage
 */
export interface SpatialCoverage {
    /**
     * 
     * @type {string}
     * @memberof SpatialCoverage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpatialCoverage
     */
    'schemaUri'?: string;
    /**
     * 
     * @type {Array<SpatialCoveragePlace>}
     * @memberof SpatialCoverage
     */
    'place'?: Array<SpatialCoveragePlace>;
}
/**
 * 
 * @export
 * @interface SpatialCoveragePlace
 */
export interface SpatialCoveragePlace {
    /**
     * 
     * @type {string}
     * @memberof SpatialCoveragePlace
     */
    'text'?: string;
    /**
     * 
     * @type {Language}
     * @memberof SpatialCoveragePlace
     */
    'language'?: Language;
}
/**
 * 
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * 
     * @type {string}
     * @memberof Subject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Subject
     */
    'schemaUri': string;
    /**
     * 
     * @type {Array<SubjectKeyword>}
     * @memberof Subject
     */
    'keyword'?: Array<SubjectKeyword>;
}
/**
 * 
 * @export
 * @interface SubjectKeyword
 */
export interface SubjectKeyword {
    /**
     * 
     * @type {string}
     * @memberof SubjectKeyword
     */
    'text': string;
    /**
     * 
     * @type {Language}
     * @memberof SubjectKeyword
     */
    'language'?: Language;
}
/**
 * 
 * @export
 * @interface Title
 */
export interface Title {
    /**
     * 
     * @type {string}
     * @memberof Title
     */
    'text': string;
    /**
     * 
     * @type {TitleType}
     * @memberof Title
     */
    'type': TitleType;
    /**
     * 
     * @type {string}
     * @memberof Title
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof Title
     */
    'endDate'?: string;
    /**
     * 
     * @type {Language}
     * @memberof Title
     */
    'language'?: Language;
}
/**
 * 
 * @export
 * @interface TitleType
 */
export interface TitleType {
    /**
     * 
     * @type {string}
     * @memberof TitleType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TitleType
     */
    'schemaUri'?: string;
}
/**
 * 
 * @export
 * @interface TraditionalKnowledgeLabel
 */
export interface TraditionalKnowledgeLabel {
    /**
     * 
     * @type {string}
     * @memberof TraditionalKnowledgeLabel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TraditionalKnowledgeLabel
     */
    'schemaUri'?: string;
}
/**
 * 
 * @export
 * @interface ValidationFailure
 */
export interface ValidationFailure {
    /**
     * 
     * @type {string}
     * @memberof ValidationFailure
     */
    'fieldId': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationFailure
     */
    'errorType': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationFailure
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ValidationFailureResponse
 */
export interface ValidationFailureResponse {
    /**
     * 
     * @type {Array<ValidationFailure>}
     * @memberof ValidationFailureResponse
     */
    'failures': Array<ValidationFailure>;
    /**
     * 
     * @type {string}
     * @memberof ValidationFailureResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationFailureResponse
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof ValidationFailureResponse
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof ValidationFailureResponse
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationFailureResponse
     */
    'instance': string;
}

/**
 * RaidApi - axios parameter creator
 * @export
 */
export const RaidApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary list raids
         * @param {number} [servicePointId] 
         * @param {Array<string>} [includeFields] The top level fields to include in each RAiD in the response body. Excludes all other fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllRaids: async (servicePointId?: number, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/raid/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (servicePointId !== undefined) {
                localVarQueryParameter['servicePointId'] = servicePointId;
            }

            if (includeFields) {
                localVarQueryParameter['includeFields'] = includeFields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary read a raid, caller must be authorized
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {number} [version] The version of the raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRaidByName: async (prefix: string, suffix: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('findRaidByName', 'prefix', prefix)
            // verify required parameter 'suffix' is not null or undefined
            assertParamExists('findRaidByName', 'suffix', suffix)
            const localVarPath = `/raid/{prefix}/{suffix}`
                .replace(`{${"prefix"}}`, encodeURIComponent(String(prefix)))
                .replace(`{${"suffix"}}`, encodeURIComponent(String(suffix)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary mint a raid
         * @param {RaidCreateRequest} raidCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintRaid: async (raidCreateRequest: RaidCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'raidCreateRequest' is not null or undefined
            assertParamExists('mintRaid', 'raidCreateRequest', raidCreateRequest)
            const localVarPath = `/raid/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(raidCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A list of the changes to the raid
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raidHistory: async (prefix: string, suffix: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('raidHistory', 'prefix', prefix)
            // verify required parameter 'suffix' is not null or undefined
            assertParamExists('raidHistory', 'suffix', suffix)
            const localVarPath = `/raid/{prefix}/{suffix}/history`
                .replace(`{${"prefix"}}`, encodeURIComponent(String(prefix)))
                .replace(`{${"suffix"}}`, encodeURIComponent(String(suffix)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {RaidUpdateRequest} raidUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaid: async (prefix: string, suffix: string, raidUpdateRequest: RaidUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('updateRaid', 'prefix', prefix)
            // verify required parameter 'suffix' is not null or undefined
            assertParamExists('updateRaid', 'suffix', suffix)
            // verify required parameter 'raidUpdateRequest' is not null or undefined
            assertParamExists('updateRaid', 'raidUpdateRequest', raidUpdateRequest)
            const localVarPath = `/raid/{prefix}/{suffix}`
                .replace(`{${"prefix"}}`, encodeURIComponent(String(prefix)))
                .replace(`{${"suffix"}}`, encodeURIComponent(String(suffix)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(raidUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RaidApi - functional programming interface
 * @export
 */
export const RaidApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RaidApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary list raids
         * @param {number} [servicePointId] 
         * @param {Array<string>} [includeFields] The top level fields to include in each RAiD in the response body. Excludes all other fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllRaids(servicePointId?: number, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RaidDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllRaids(servicePointId, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary read a raid, caller must be authorized
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {number} [version] The version of the raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRaidByName(prefix: string, suffix: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaidDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRaidByName(prefix, suffix, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary mint a raid
         * @param {RaidCreateRequest} raidCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintRaid(raidCreateRequest: RaidCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaidDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintRaid(raidCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A list of the changes to the raid
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async raidHistory(prefix: string, suffix: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RaidChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.raidHistory(prefix, suffix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {RaidUpdateRequest} raidUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaid(prefix: string, suffix: string, raidUpdateRequest: RaidUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RaidDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaid(prefix, suffix, raidUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RaidApi - factory interface
 * @export
 */
export const RaidApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RaidApiFp(configuration)
    return {
        /**
         * 
         * @summary list raids
         * @param {number} [servicePointId] 
         * @param {Array<string>} [includeFields] The top level fields to include in each RAiD in the response body. Excludes all other fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllRaids(servicePointId?: number, includeFields?: Array<string>, options?: any): AxiosPromise<Array<RaidDto>> {
            return localVarFp.findAllRaids(servicePointId, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary read a raid, caller must be authorized
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {number} [version] The version of the raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRaidByName(prefix: string, suffix: string, version?: number, options?: any): AxiosPromise<RaidDto> {
            return localVarFp.findRaidByName(prefix, suffix, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary mint a raid
         * @param {RaidCreateRequest} raidCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintRaid(raidCreateRequest: RaidCreateRequest, options?: any): AxiosPromise<RaidDto> {
            return localVarFp.mintRaid(raidCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A list of the changes to the raid
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raidHistory(prefix: string, suffix: string, options?: any): AxiosPromise<Array<RaidChange>> {
            return localVarFp.raidHistory(prefix, suffix, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} prefix Prefix of the raid handle
         * @param {string} suffix Suffix of the raid handle
         * @param {RaidUpdateRequest} raidUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaid(prefix: string, suffix: string, raidUpdateRequest: RaidUpdateRequest, options?: any): AxiosPromise<RaidDto> {
            return localVarFp.updateRaid(prefix, suffix, raidUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RaidApi - object-oriented interface
 * @export
 * @class RaidApi
 * @extends {BaseAPI}
 */
export class RaidApi extends BaseAPI {
    /**
     * 
     * @summary list raids
     * @param {number} [servicePointId] 
     * @param {Array<string>} [includeFields] The top level fields to include in each RAiD in the response body. Excludes all other fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidApi
     */
    public findAllRaids(servicePointId?: number, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return RaidApiFp(this.configuration).findAllRaids(servicePointId, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary read a raid, caller must be authorized
     * @param {string} prefix Prefix of the raid handle
     * @param {string} suffix Suffix of the raid handle
     * @param {number} [version] The version of the raid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidApi
     */
    public findRaidByName(prefix: string, suffix: string, version?: number, options?: AxiosRequestConfig) {
        return RaidApiFp(this.configuration).findRaidByName(prefix, suffix, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary mint a raid
     * @param {RaidCreateRequest} raidCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidApi
     */
    public mintRaid(raidCreateRequest: RaidCreateRequest, options?: AxiosRequestConfig) {
        return RaidApiFp(this.configuration).mintRaid(raidCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A list of the changes to the raid
     * @param {string} prefix Prefix of the raid handle
     * @param {string} suffix Suffix of the raid handle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidApi
     */
    public raidHistory(prefix: string, suffix: string, options?: AxiosRequestConfig) {
        return RaidApiFp(this.configuration).raidHistory(prefix, suffix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} prefix Prefix of the raid handle
     * @param {string} suffix Suffix of the raid handle
     * @param {RaidUpdateRequest} raidUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidApi
     */
    public updateRaid(prefix: string, suffix: string, raidUpdateRequest: RaidUpdateRequest, options?: AxiosRequestConfig) {
        return RaidApiFp(this.configuration).updateRaid(prefix, suffix, raidUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServicePointApi - axios parameter creator
 * @export
 */
export const ServicePointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServicePointCreateRequest} servicePointCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePoint: async (servicePointCreateRequest: ServicePointCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'servicePointCreateRequest' is not null or undefined
            assertParamExists('createServicePoint', 'servicePointCreateRequest', servicePointCreateRequest)
            const localVarPath = `/service-point/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicePointCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllServicePoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-point/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id The id of the service point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findServicePointById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findServicePointById', 'id', id)
            const localVarPath = `/service-point/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id The id of the service point
         * @param {ServicePointUpdateRequest} servicePointUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServicePoint: async (id: number, servicePointUpdateRequest: ServicePointUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateServicePoint', 'id', id)
            // verify required parameter 'servicePointUpdateRequest' is not null or undefined
            assertParamExists('updateServicePoint', 'servicePointUpdateRequest', servicePointUpdateRequest)
            const localVarPath = `/service-point/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicePointUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicePointApi - functional programming interface
 * @export
 */
export const ServicePointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicePointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ServicePointCreateRequest} servicePointCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServicePoint(servicePointCreateRequest: ServicePointCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServicePoint(servicePointCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllServicePoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllServicePoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id The id of the service point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findServicePointById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findServicePointById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id The id of the service point
         * @param {ServicePointUpdateRequest} servicePointUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServicePoint(id: number, servicePointUpdateRequest: ServicePointUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServicePoint(id, servicePointUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServicePointApi - factory interface
 * @export
 */
export const ServicePointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicePointApiFp(configuration)
    return {
        /**
         * 
         * @param {ServicePointCreateRequest} servicePointCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePoint(servicePointCreateRequest: ServicePointCreateRequest, options?: any): AxiosPromise<ServicePoint> {
            return localVarFp.createServicePoint(servicePointCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllServicePoints(options?: any): AxiosPromise<Array<ServicePoint>> {
            return localVarFp.findAllServicePoints(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id The id of the service point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findServicePointById(id: number, options?: any): AxiosPromise<ServicePoint> {
            return localVarFp.findServicePointById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id The id of the service point
         * @param {ServicePointUpdateRequest} servicePointUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServicePoint(id: number, servicePointUpdateRequest: ServicePointUpdateRequest, options?: any): AxiosPromise<ServicePoint> {
            return localVarFp.updateServicePoint(id, servicePointUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServicePointApi - object-oriented interface
 * @export
 * @class ServicePointApi
 * @extends {BaseAPI}
 */
export class ServicePointApi extends BaseAPI {
    /**
     * 
     * @param {ServicePointCreateRequest} servicePointCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointApi
     */
    public createServicePoint(servicePointCreateRequest: ServicePointCreateRequest, options?: AxiosRequestConfig) {
        return ServicePointApiFp(this.configuration).createServicePoint(servicePointCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointApi
     */
    public findAllServicePoints(options?: AxiosRequestConfig) {
        return ServicePointApiFp(this.configuration).findAllServicePoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id The id of the service point
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointApi
     */
    public findServicePointById(id: number, options?: AxiosRequestConfig) {
        return ServicePointApiFp(this.configuration).findServicePointById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id The id of the service point
     * @param {ServicePointUpdateRequest} servicePointUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePointApi
     */
    public updateServicePoint(id: number, servicePointUpdateRequest: ServicePointUpdateRequest, options?: AxiosRequestConfig) {
        return ServicePointApiFp(this.configuration).updateServicePoint(id, servicePointUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


