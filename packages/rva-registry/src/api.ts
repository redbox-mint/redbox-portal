/* tslint:disable */
/* eslint-disable */
/**
 * Vocabulary Registry API
 * Public access to the Vocabulary Registry API
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: services@ardc.edu.au
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AccessPoint {
    'ap-api-sparql'?: ApApiSparql;
    'ap-file'?: ApFile;
    'ap-sesame-download'?: ApSesameDownload;
    'ap-sissvoc'?: ApSissvoc;
    'ap-web-page'?: ApWebPage;
    'id'?: number;
    'source': AccessPointSourceEnum;
    'discriminator': AccessPointDiscriminatorEnum;
}

export const AccessPointSourceEnum = {
    System: 'system',
    User: 'user'
} as const;

export type AccessPointSourceEnum = typeof AccessPointSourceEnum[keyof typeof AccessPointSourceEnum];
export const AccessPointDiscriminatorEnum = {
    ApiSparql: 'apiSparql',
    File: 'file',
    SesameDownload: 'sesameDownload',
    Sissvoc: 'sissvoc',
    WebPage: 'webPage'
} as const;

export type AccessPointDiscriminatorEnum = typeof AccessPointDiscriminatorEnum[keyof typeof AccessPointDiscriminatorEnum];

export interface AccessPointList {
    'access-point'?: Array<AccessPoint>;
}
export interface ApApiSparql {
    'url': string;
}
export interface ApFile {
    'format'?: string;
    'upload-id': number;
    'url'?: string;
}
export interface ApSesameDownload {
    'url-prefix'?: string;
}
export interface ApSissvoc {
    'url-prefix'?: string;
}
export interface ApWebPage {
    'url': string;
}
export interface LanguageDetails {
    'tag'?: string;
    'description'?: string;
}
export interface LanguageList {
    'language-details'?: Array<LanguageDetails>;
}
export interface ModelError {
    'message'?: string;
    'constraintViolation'?: Array<ValidationError>;
}
export interface OwnedVocabulary {
    'id'?: number;
    'status': OwnedVocabularyStatusEnum;
    'has-draft'?: boolean;
    'owner': string;
    'slug'?: string;
    'title': string;
}

export const OwnedVocabularyStatusEnum = {
    Published: 'published',
    Draft: 'draft',
    Deprecated: 'deprecated'
} as const;

export type OwnedVocabularyStatusEnum = typeof OwnedVocabularyStatusEnum[keyof typeof OwnedVocabularyStatusEnum];

export interface OwnedVocabularyList {
    'owned-vocabulary'?: Array<OwnedVocabulary>;
}
export interface PoolpartyProject {
    'server-id'?: number;
    'project-id'?: string;
}
export interface RelatedEntity {
    'related-entity-identifier'?: Array<RelatedEntityIdentifier>;
    'url'?: Array<string>;
    'id'?: number;
    'type': RelatedEntityTypeEnum;
    'owner': string;
    'title': string;
    'email'?: string;
    'phone'?: string;
}

export const RelatedEntityTypeEnum = {
    Party: 'party',
    Service: 'service',
    Vocabulary: 'vocabulary'
} as const;

export type RelatedEntityTypeEnum = typeof RelatedEntityTypeEnum[keyof typeof RelatedEntityTypeEnum];

export interface RelatedEntityIdentifier {
    'id'?: number;
    'identifier-type': RelatedEntityIdentifierIdentifierTypeEnum;
    'identifier-value': string;
}

export const RelatedEntityIdentifierIdentifierTypeEnum = {
    AuAnlPeau: 'auAnlPeau',
    Doi: 'doi',
    Handle: 'handle',
    Infouri: 'infouri',
    Isil: 'isil',
    Isni: 'isni',
    Local: 'local',
    Orcid: 'orcid',
    Purl: 'purl',
    ResearcherId: 'researcherID',
    Ror: 'ror',
    Uri: 'uri',
    Viaf: 'viaf'
} as const;

export type RelatedEntityIdentifierIdentifierTypeEnum = typeof RelatedEntityIdentifierIdentifierTypeEnum[keyof typeof RelatedEntityIdentifierIdentifierTypeEnum];

export interface RelatedEntityList {
    'related-entity'?: Array<RelatedEntity>;
}
export interface RelatedEntityRef {
    'relation': Array<RelatedEntityRefRelationEnum>;
    'related-entity'?: RelatedEntity;
    'id': number;
}

export const RelatedEntityRefRelationEnum = {
    PublishedBy: 'publishedBy',
    HasAuthor: 'hasAuthor',
    HasContributor: 'hasContributor',
    PointOfContact: 'pointOfContact',
    ImplementedBy: 'implementedBy',
    ConsumerOf: 'consumerOf',
    IsFundedBy: 'isFundedBy',
    HasAssociationWith: 'hasAssociationWith',
    IsPresentedBy: 'isPresentedBy',
    IsUsedBy: 'isUsedBy',
    IsDerivedFrom: 'isDerivedFrom',
    Enriches: 'enriches',
    IsPartOf: 'isPartOf'
} as const;

export type RelatedEntityRefRelationEnum = typeof RelatedEntityRefRelationEnum[keyof typeof RelatedEntityRefRelationEnum];

export interface RelatedVocabulary {
    'id'?: number;
    'status': RelatedVocabularyStatusEnum;
    'owner': string;
    'slug'?: string;
    'title': string;
    'acronym'?: string;
    'description'?: string;
}

export const RelatedVocabularyStatusEnum = {
    Published: 'published',
    Draft: 'draft',
    Deprecated: 'deprecated'
} as const;

export type RelatedVocabularyStatusEnum = typeof RelatedVocabularyStatusEnum[keyof typeof RelatedVocabularyStatusEnum];

export interface RelatedVocabularyRef {
    'relation': Array<RelatedVocabularyRefRelationEnum>;
    'related-vocabulary': RelatedVocabulary;
    'id': number;
}

export const RelatedVocabularyRefRelationEnum = {
    HasAssociationWith: 'hasAssociationWith',
    IsDerivedFrom: 'isDerivedFrom',
    Enriches: 'enriches',
    IsPartOf: 'isPartOf'
} as const;

export type RelatedVocabularyRefRelationEnum = typeof RelatedVocabularyRefRelationEnum[keyof typeof RelatedVocabularyRefRelationEnum];

export interface Result {
    'stringValue'?: string;
    'booleanValue'?: boolean;
    'integerValue'?: number;
}
export interface ResultPair {
    'result-key'?: string;
    'result-value'?: string;
}
export interface ReverseRelatedVocabulary {
    'related-entity-relation'?: Array<ReverseRelatedVocabularyRelatedEntityRelationEnum>;
    'related-vocabulary-relation'?: Array<ReverseRelatedVocabularyRelatedVocabularyRelationEnum>;
    'related-vocabulary': RelatedVocabulary;
}

export const ReverseRelatedVocabularyRelatedEntityRelationEnum = {
    PublishedBy: 'publishedBy',
    HasAuthor: 'hasAuthor',
    HasContributor: 'hasContributor',
    PointOfContact: 'pointOfContact',
    ImplementedBy: 'implementedBy',
    ConsumerOf: 'consumerOf',
    IsFundedBy: 'isFundedBy',
    HasAssociationWith: 'hasAssociationWith',
    IsPresentedBy: 'isPresentedBy',
    IsUsedBy: 'isUsedBy',
    IsDerivedFrom: 'isDerivedFrom',
    Enriches: 'enriches',
    IsPartOf: 'isPartOf'
} as const;

export type ReverseRelatedVocabularyRelatedEntityRelationEnum = typeof ReverseRelatedVocabularyRelatedEntityRelationEnum[keyof typeof ReverseRelatedVocabularyRelatedEntityRelationEnum];
export const ReverseRelatedVocabularyRelatedVocabularyRelationEnum = {
    HasAssociationWith: 'hasAssociationWith',
    IsDerivedFrom: 'isDerivedFrom',
    Enriches: 'enriches',
    IsPartOf: 'isPartOf'
} as const;

export type ReverseRelatedVocabularyRelatedVocabularyRelationEnum = typeof ReverseRelatedVocabularyRelatedVocabularyRelationEnum[keyof typeof ReverseRelatedVocabularyRelatedVocabularyRelationEnum];

export interface ReverseRelatedVocabularyList {
    'reverse-related-vocabulary'?: Array<ReverseRelatedVocabulary>;
}
export interface Role {
    'id'?: string;
    'typeId'?: RoleTypeIdEnum;
    'fullName'?: string;
}

export const RoleTypeIdEnum = {
    RoleUser: 'ROLE_USER',
    RoleOrganisational: 'ROLE_ORGANISATIONAL',
    RoleFunctional: 'ROLE_FUNCTIONAL',
    RoleDoiAppid: 'ROLE_DOI_APPID'
} as const;

export type RoleTypeIdEnum = typeof RoleTypeIdEnum[keyof typeof RoleTypeIdEnum];

export interface Subject {
    'source': string;
    'label': string;
    'notation'?: string;
    'iri'?: string;
}
export interface Subscription {
    'notification-mode': SubscriptionNotificationModeEnum;
    'element-type': SubscriptionElementTypeEnum;
    'element-id'?: string;
    'title'?: string;
    'deleted'?: boolean;
}

export const SubscriptionNotificationModeEnum = {
    Email: 'email'
} as const;

export type SubscriptionNotificationModeEnum = typeof SubscriptionNotificationModeEnum[keyof typeof SubscriptionNotificationModeEnum];
export const SubscriptionElementTypeEnum = {
    System: 'system',
    Owner: 'owner',
    Vocabulary: 'vocabulary'
} as const;

export type SubscriptionElementTypeEnum = typeof SubscriptionElementTypeEnum[keyof typeof SubscriptionElementTypeEnum];

export interface SubscriptionList {
    'subscription'?: Array<Subscription>;
}
export interface Subtask {
    'subtaskProviderType'?: SubtaskSubtaskProviderTypeEnum;
    'operation'?: SubtaskOperationEnum;
    'priority'?: number;
    'provider'?: string;
    'subtaskProperties'?: { [key: string]: string; };
    'status'?: SubtaskStatusEnum;
    'results'?: { [key: string]: string; };
}

export const SubtaskSubtaskProviderTypeEnum = {
    Backup: 'backup',
    Harvest: 'harvest',
    Importer: 'importer',
    Publish: 'publish',
    Transform: 'transform'
} as const;

export type SubtaskSubtaskProviderTypeEnum = typeof SubtaskSubtaskProviderTypeEnum[keyof typeof SubtaskSubtaskProviderTypeEnum];
export const SubtaskOperationEnum = {
    Insert: 'insert',
    Delete: 'delete',
    Perform: 'perform'
} as const;

export type SubtaskOperationEnum = typeof SubtaskOperationEnum[keyof typeof SubtaskOperationEnum];
export const SubtaskStatusEnum = {
    New: 'new',
    Partial: 'partial',
    Success: 'success',
    Error: 'error'
} as const;

export type SubtaskStatusEnum = typeof SubtaskStatusEnum[keyof typeof SubtaskStatusEnum];

export interface SubtaskOutcome {
    'subtask-result'?: Array<ResultPair>;
    'status'?: SubtaskOutcomeStatusEnum;
    'subtask-provider-type'?: SubtaskOutcomeSubtaskProviderTypeEnum;
    'provider'?: string;
    'operation'?: SubtaskOutcomeOperationEnum;
}

export const SubtaskOutcomeStatusEnum = {
    New: 'new',
    Partial: 'partial',
    Success: 'success',
    Error: 'error'
} as const;

export type SubtaskOutcomeStatusEnum = typeof SubtaskOutcomeStatusEnum[keyof typeof SubtaskOutcomeStatusEnum];
export const SubtaskOutcomeSubtaskProviderTypeEnum = {
    Backup: 'backup',
    Harvest: 'harvest',
    Importer: 'importer',
    Publish: 'publish',
    Transform: 'transform'
} as const;

export type SubtaskOutcomeSubtaskProviderTypeEnum = typeof SubtaskOutcomeSubtaskProviderTypeEnum[keyof typeof SubtaskOutcomeSubtaskProviderTypeEnum];
export const SubtaskOutcomeOperationEnum = {
    Insert: 'insert',
    Delete: 'delete',
    Perform: 'perform'
} as const;

export type SubtaskOutcomeOperationEnum = typeof SubtaskOutcomeOperationEnum[keyof typeof SubtaskOutcomeOperationEnum];

export interface Task {
    'status'?: TaskStatusEnum;
    'vocabularyId'?: number;
    'versionId'?: number;
    'subtasks'?: Array<Subtask>;
    'results'?: { [key: string]: string; };
}

export const TaskStatusEnum = {
    New: 'new',
    Partial: 'partial',
    Success: 'success',
    Error: 'error'
} as const;

export type TaskStatusEnum = typeof TaskStatusEnum[keyof typeof TaskStatusEnum];

export interface TaskOutcome {
    'subtask-outcome'?: Array<SubtaskOutcome>;
    'task-result'?: Array<ResultPair>;
    'version-id'?: number;
    'status'?: TaskOutcomeStatusEnum;
}

export const TaskOutcomeStatusEnum = {
    New: 'new',
    Partial: 'partial',
    Success: 'success',
    Error: 'error'
} as const;

export type TaskOutcomeStatusEnum = typeof TaskOutcomeStatusEnum[keyof typeof TaskOutcomeStatusEnum];

export interface UserInfo {
    'id'?: string;
    'authenticationServiceId'?: UserInfoAuthenticationServiceIdEnum;
    'fullName'?: string;
    'isSuperUser'?: boolean;
    'parentRole'?: Array<Role>;
}

export const UserInfoAuthenticationServiceIdEnum = {
    AuthenticationBuiltIn: 'AUTHENTICATION_BUILT_IN',
    AuthenticationLdap: 'AUTHENTICATION_LDAP',
    AuthenticationShibboleth: 'AUTHENTICATION_SHIBBOLETH',
    AuthenticationSocialFacebook: 'AUTHENTICATION_SOCIAL_FACEBOOK',
    AuthenticationSocialGoogle: 'AUTHENTICATION_SOCIAL_GOOGLE',
    AuthenticationSocialTwitter: 'AUTHENTICATION_SOCIAL_TWITTER'
} as const;

export type UserInfoAuthenticationServiceIdEnum = typeof UserInfoAuthenticationServiceIdEnum[keyof typeof UserInfoAuthenticationServiceIdEnum];

export interface ValidationError {
    'message'?: string;
    'path'?: string;
}
export interface Version {
    'browse-flag'?: Array<VersionBrowseFlagEnum>;
    'access-point'?: Array<AccessPoint>;
    'id'?: number;
    'status': VersionStatusEnum;
    'title': string;
    'slug'?: string;
    'note'?: string;
    'release-date'?: string;
    'do-poolparty-harvest'?: boolean;
    'do-import'?: boolean;
    'do-publish'?: boolean;
    'force-workflow'?: boolean;
}

export const VersionBrowseFlagEnum = {
    MaySortByNotation: 'maySortByNotation',
    DefaultSortByNotation: 'defaultSortByNotation',
    NotationAlpha: 'notationAlpha',
    NotationFloat: 'notationFloat',
    NotationDotted: 'notationDotted',
    DefaultDisplayNotation: 'defaultDisplayNotation',
    IncludeConceptSchemes: 'includeConceptSchemes',
    IncludeCollections: 'includeCollections',
    MayResolveResources: 'mayResolveResources'
} as const;

export type VersionBrowseFlagEnum = typeof VersionBrowseFlagEnum[keyof typeof VersionBrowseFlagEnum];
export const VersionStatusEnum = {
    Current: 'current',
    Superseded: 'superseded'
} as const;

export type VersionStatusEnum = typeof VersionStatusEnum[keyof typeof VersionStatusEnum];

export interface VersionArtefact {
    'id'?: number;
    'status': VersionArtefactStatusEnum;
    'type': VersionArtefactTypeEnum;
}

export const VersionArtefactStatusEnum = {
    Current: 'current',
    Pending: 'pending'
} as const;

export type VersionArtefactStatusEnum = typeof VersionArtefactStatusEnum[keyof typeof VersionArtefactStatusEnum];
export const VersionArtefactTypeEnum = {
    ConceptList: 'conceptList',
    ConceptTree: 'conceptTree',
    HarvestPoolparty: 'harvestPoolparty',
    ResourceDocs: 'resourceDocs'
} as const;

export type VersionArtefactTypeEnum = typeof VersionArtefactTypeEnum[keyof typeof VersionArtefactTypeEnum];

export interface VersionArtefactList {
    'version-artefact'?: Array<VersionArtefact>;
}
export interface VersionList {
    'version'?: Array<Version>;
}
export interface Vocabulary {
    'poolparty-project'?: PoolpartyProject;
    'subject'?: Array<Subject>;
    'version'?: Array<Version>;
    'other-language'?: Array<string>;
    'top-concept'?: Array<string>;
    'related-entity-ref': Array<RelatedEntityRef>;
    'related-vocabulary-ref'?: Array<RelatedVocabularyRef>;
    'language-list'?: LanguageList;
    'workflow-outcome'?: WorkflowOutcome;
    'id'?: number;
    'status': VocabularyStatusEnum;
    'owner': string;
    'slug'?: string;
    'title': string;
    'acronym'?: string;
    'description'?: string;
    'note'?: string;
    'revision-cycle'?: string;
    'creation-date'?: string;
    'primary-language'?: string;
    'licence'?: string;
}

export const VocabularyStatusEnum = {
    Published: 'published',
    Draft: 'draft',
    Deprecated: 'deprecated'
} as const;

export type VocabularyStatusEnum = typeof VocabularyStatusEnum[keyof typeof VocabularyStatusEnum];

export interface VocabularyList {
    'vocabulary'?: Array<Vocabulary>;
}
export interface WorkflowOutcome {
    'task-outcome'?: Array<TaskOutcome>;
    'vocabulary-id'?: number;
}

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is only available to administrator users.
         * @summary Backup all PoolParty projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupAllPoolPartyProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/adminApi/backup/PoolParty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users.
         * @summary Backup one PoolParty project.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupPoolPartyProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('backupPoolPartyProject', 'projectId', projectId)
            const localVarPath = `/adminApi/backup/PoolParty/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users.
         * @summary Force a soft commit of pending changes to the Solr collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitSolr: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/adminApi/solr/commit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users.
         * @summary Generate email notifications.
         * @param {string} [startDate] Start date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-10-26T13:00:00. If not specified, defaults to a week before the current date/time, and endDate is taken as the current date/time (irrespective of any value given for endDate).
         * @param {string} [endDate] End date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-11-26T00:00:00. If not specified, defaults to the current date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateNotificationEmails: async (startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/adminApi/notification/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users.
         * @summary Get a task.
         * @param {number} taskId The ID of the task to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTask', 'taskId', taskId)
            const localVarPath = `/adminApi/workflow/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users.
         * @summary Get all the current (published and deprecated) and draft vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabulariesIncludingDraft: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/adminApi/resource/vocabularies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users.
         * @summary Force Solr indexing of all vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/adminApi/solr/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users.
         * @summary Force Solr indexing of one vocabulary.
         * @param {number} vocabularyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexOne: async (vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('indexOne', 'vocabularyId', vocabularyId)
            const localVarPath = `/adminApi/solr/index/{vocabularyId}`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users. The task must exist in the database. There must be a current instance of the vocabulary and version.
         * @summary Run a task.
         * @param {number} taskId The ID of the task to run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTask: async (taskId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('runTask', 'taskId', taskId)
            const localVarPath = `/adminApi/workflow/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is only available to administrator users. The tasks must exist in the database. There must be a current instance of the vocabularies and versions.
         * @summary Run a set of tasks for one vocabulary.
         * @param {Array<number>} taskId The IDs of the tasks to run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTaskSet: async (taskId: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('runTaskSet', 'taskId', taskId)
            const localVarPath = `/adminApi/workflow/taskSet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            if (taskId) {
                localVarQueryParameter['taskId'] = taskId;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is only available to administrator users.
         * @summary Backup all PoolParty projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backupAllPoolPartyProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backupAllPoolPartyProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.backupAllPoolPartyProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users.
         * @summary Backup one PoolParty project.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backupPoolPartyProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backupPoolPartyProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.backupPoolPartyProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users.
         * @summary Force a soft commit of pending changes to the Solr collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitSolr(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitSolr(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.commitSolr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users.
         * @summary Generate email notifications.
         * @param {string} [startDate] Start date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-10-26T13:00:00. If not specified, defaults to a week before the current date/time, and endDate is taken as the current date/time (irrespective of any value given for endDate).
         * @param {string} [endDate] End date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-11-26T00:00:00. If not specified, defaults to the current date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateNotificationEmails(startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateNotificationEmails(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.generateNotificationEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users.
         * @summary Get a task.
         * @param {number} taskId The ID of the task to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users.
         * @summary Get all the current (published and deprecated) and draft vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVocabulariesIncludingDraft(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabularyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVocabulariesIncludingDraft(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getVocabulariesIncludingDraft']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users.
         * @summary Force Solr indexing of all vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.indexAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users.
         * @summary Force Solr indexing of one vocabulary.
         * @param {number} vocabularyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexOne(vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexOne(vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.indexOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users. The task must exist in the database. There must be a current instance of the vocabulary and version.
         * @summary Run a task.
         * @param {number} taskId The ID of the task to run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runTask(taskId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runTask(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.runTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is only available to administrator users. The tasks must exist in the database. There must be a current instance of the vocabularies and versions.
         * @summary Run a set of tasks for one vocabulary.
         * @param {Array<number>} taskId The IDs of the tasks to run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runTaskSet(taskId: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOutcome>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runTaskSet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.runTaskSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * This method is only available to administrator users.
         * @summary Backup all PoolParty projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupAllPoolPartyProjects(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.backupAllPoolPartyProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users.
         * @summary Backup one PoolParty project.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupPoolPartyProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.backupPoolPartyProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users.
         * @summary Force a soft commit of pending changes to the Solr collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitSolr(options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.commitSolr(options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users.
         * @summary Generate email notifications.
         * @param {string} [startDate] Start date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-10-26T13:00:00. If not specified, defaults to a week before the current date/time, and endDate is taken as the current date/time (irrespective of any value given for endDate).
         * @param {string} [endDate] End date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-11-26T00:00:00. If not specified, defaults to the current date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateNotificationEmails(startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.generateNotificationEmails(startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users.
         * @summary Get a task.
         * @param {number} taskId The ID of the task to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: number, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.getTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users.
         * @summary Get all the current (published and deprecated) and draft vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabulariesIncludingDraft(options?: RawAxiosRequestConfig): AxiosPromise<VocabularyList> {
            return localVarFp.getVocabulariesIncludingDraft(options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users.
         * @summary Force Solr indexing of all vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexAll(options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.indexAll(options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users.
         * @summary Force Solr indexing of one vocabulary.
         * @param {number} vocabularyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexOne(vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.indexOne(vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users. The task must exist in the database. There must be a current instance of the vocabulary and version.
         * @summary Run a task.
         * @param {number} taskId The ID of the task to run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTask(taskId: number, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.runTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is only available to administrator users. The tasks must exist in the database. There must be a current instance of the vocabularies and versions.
         * @summary Run a set of tasks for one vocabulary.
         * @param {Array<number>} taskId The IDs of the tasks to run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTaskSet(taskId: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowOutcome> {
            return localVarFp.runTaskSet(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * This method is only available to administrator users.
     * @summary Backup all PoolParty projects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public backupAllPoolPartyProjects(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).backupAllPoolPartyProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users.
     * @summary Backup one PoolParty project.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public backupPoolPartyProject(projectId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).backupPoolPartyProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users.
     * @summary Force a soft commit of pending changes to the Solr collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commitSolr(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).commitSolr(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users.
     * @summary Generate email notifications.
     * @param {string} [startDate] Start date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-10-26T13:00:00. If not specified, defaults to a week before the current date/time, and endDate is taken as the current date/time (irrespective of any value given for endDate).
     * @param {string} [endDate] End date/time of registry events to consider. Values are specified in UTC: required format YYYY-MM-DDTHH:MM:SS, e.g., 2017-11-26T00:00:00. If not specified, defaults to the current date/time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateNotificationEmails(startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).generateNotificationEmails(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users.
     * @summary Get a task.
     * @param {number} taskId The ID of the task to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTask(taskId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users.
     * @summary Get all the current (published and deprecated) and draft vocabularies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVocabulariesIncludingDraft(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getVocabulariesIncludingDraft(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users.
     * @summary Force Solr indexing of all vocabularies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public indexAll(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).indexAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users.
     * @summary Force Solr indexing of one vocabulary.
     * @param {number} vocabularyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public indexOne(vocabularyId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).indexOne(vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users. The task must exist in the database. There must be a current instance of the vocabulary and version.
     * @summary Run a task.
     * @param {number} taskId The ID of the task to run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runTask(taskId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).runTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is only available to administrator users. The tasks must exist in the database. There must be a current instance of the vocabularies and versions.
     * @summary Run a set of tasks for one vocabulary.
     * @param {Array<number>} taskId The IDs of the tasks to run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runTaskSet(taskId: Array<number>, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).runTaskSet(taskId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new related entity.
         * @param {RelatedEntity} body The related entity to be added.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelatedEntity: async (body: RelatedEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRelatedEntity', 'body', body)
            const localVarPath = `/api/resource/relatedEntities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/xml';
            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The response contains the ID of the resulting upload in the integerValue field, and the sanitized filename in the stringValue field.
         * @summary Upload a file.
         * @param {string} owner The owner of the upload
         * @param {string} format The type of the upload
         * @param {File} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload: async (owner: string, format: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('createUpload', 'owner', owner)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('createUpload', 'format', format)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createUpload', 'file', file)
            const localVarPath = `/api/resource/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
            localVarHeaderParameter['Accept'] = 'application/xml,application/json';
            const formHeaders = (localVarFormParams as { getHeaders?: () => Record<string, string> }).getHeaders?.();
            if (formHeaders) {
                Object.assign(localVarHeaderParameter, formHeaders);
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new vocabulary.
         * @param {Vocabulary} body The vocabulary to be added.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVocabulary: async (body: Vocabulary, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createVocabulary', 'body', body)
            const localVarPath = `/api/resource/vocabularies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/xml';
            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a related entity.
         * @param {number} relatedEntityId The ID of the related entity to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelatedEntity: async (relatedEntityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relatedEntityId' is not null or undefined
            assertParamExists('deleteRelatedEntity', 'relatedEntityId', relatedEntityId)
            const localVarPath = `/api/resource/relatedEntities/{relatedEntityId}`
                .replace(`{${"relatedEntityId"}}`, encodeURIComponent(String(relatedEntityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be deleted.
         * @param {boolean} [deleteCurrent] Whether or not to delete the current version.
         * @param {boolean} [deleteDraft] Whether or not to delete the draft version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVocabulary: async (vocabularyId: number, deleteCurrent?: boolean, deleteDraft?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('deleteVocabulary', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            if (deleteCurrent !== undefined) {
                localVarQueryParameter['deleteCurrent'] = deleteCurrent;
            }

            if (deleteDraft !== undefined) {
                localVarQueryParameter['deleteDraft'] = deleteDraft;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In this version of the download method, a download format is specified as a query parameter. The response will include a Content-Disposition header that specifies a full filename based on the underlying data; its extension may be different from the value of the format query parameter.
         * @summary Get a download.
         * @param {number} downloadId The Id of the download.
         * @param {string} [format] The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (downloadId: number, format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('download', 'downloadId', downloadId)
            const localVarPath = `/api/resource/downloads/{downloadId}`
                .replace(`{${"downloadId"}}`, encodeURIComponent(String(downloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In this version of the download method, the last component of the URL specifies a filename and an extension. The response will include a Content-Disposition header that specifies a filename and extension based on the underlying data; they may be different from the values specified.
         * @summary Get a download.
         * @param {number} downloadId The Id of the download.
         * @param {string} filename The filename of the download.
         * @param {string} extension The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWithFilename: async (downloadId: number, filename: string, extension: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('downloadWithFilename', 'downloadId', downloadId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('downloadWithFilename', 'filename', filename)
            // verify required parameter 'extension' is not null or undefined
            assertParamExists('downloadWithFilename', 'extension', extension)
            const localVarPath = `/api/resource/downloads/{downloadId}/{filename}.{extension}`
                .replace(`{${"downloadId"}}`, encodeURIComponent(String(downloadId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)))
                .replace(`{${"extension"}}`, encodeURIComponent(String(extension)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current access points of a version, by its version id.
         * @param {number} versionId The ID of the version from which to get the current access points.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessPointsForVersionById: async (versionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getAccessPointsForVersionById', 'versionId', versionId)
            const localVarPath = `/api/resource/versions/{versionId}/accessPoints`
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The result list contains one element for each vocabulary owned by the caller. The status attribute will be \"draft\" if there is only a draft instance of the vocabulary; in this case, hasDraft will be true. Otherwise, status will be either \"published\" or \"deprecated\", and hasDraft will be true if there is also a draft instance.
         * @summary Get a list of vocabularies owned by the caller.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnedVocabularies: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/resource/ownedVocabularies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all current related entities, optionally, filtered by related entity type. Results do not include related entity identifiers.
         * @param {GetRelatedEntitiesRelatedEntityTypeEnum} [relatedEntityType] The type of the related entities to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedEntities: async (relatedEntityType?: GetRelatedEntitiesRelatedEntityTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/resource/relatedEntities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (relatedEntityType !== undefined) {
                localVarQueryParameter['relatedEntityType'] = relatedEntityType;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current related entities of a vocabulary, by its vocabulary id.
         * @param {number} vocabularyId The ID of the vocabulary from which to get the current related entities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedEntitiesForVocabularyById: async (vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('getRelatedEntitiesForVocabularyById', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}/relatedEntities`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a current related entity by its id.
         * @param {number} relatedEntityId The ID of the related entity to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedEntityById: async (relatedEntityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relatedEntityId' is not null or undefined
            assertParamExists('getRelatedEntityById', 'relatedEntityId', relatedEntityId)
            const localVarPath = `/api/resource/relatedEntities/{relatedEntityId}`
                .replace(`{${"relatedEntityId"}}`, encodeURIComponent(String(relatedEntityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current concept tree of a version, by its version id.
         * @param {number} versionId The ID of the version from which to get the concept tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionArtefactConceptTree: async (versionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getVersionArtefactConceptTree', 'versionId', versionId)
            const localVarPath = `/api/resource/versions/{versionId}/versionArtefacts/conceptTree`
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current version artefacts of a version, by its version id. Results can be filtered by version artefact type.
         * @param {number} versionId The ID of the version from which to get the version artefacts.
         * @param {GetVersionArtefactsTypeEnum} [type] Version artefact type used to filter results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionArtefacts: async (versionId: number, type?: GetVersionArtefactsTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getVersionArtefacts', 'versionId', versionId)
            const localVarPath = `/api/resource/versions/{versionId}/versionArtefacts`
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a current version by its id.
         * @param {number} versionId The ID of the version to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionById: async (versionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getVersionById', 'versionId', versionId)
            const localVarPath = `/api/resource/versions/{versionId}`
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current versions of a vocabulary, by its vocabulary id. The results are returned in reverse order of release date.
         * @param {number} vocabularyId The ID of the vocabulary from which to get the current versions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsForVocabularyById: async (vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('getVersionsForVocabularyById', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}/versions`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the current vocabularies. This includes both published and deprecated vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularies: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/resource/vocabularies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all current vocabularies related to a related entity, by the related entity\'s id.
         * @param {number} relatedEntityId The ID of the related entity for which to get the vocabularies related to it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabulariesRelatedToRelatedEntityById: async (relatedEntityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relatedEntityId' is not null or undefined
            assertParamExists('getVocabulariesRelatedToRelatedEntityById', 'relatedEntityId', relatedEntityId)
            const localVarPath = `/api/resource/relatedEntities/{relatedEntityId}/reverseRelatedVocabularies`
                .replace(`{${"relatedEntityId"}}`, encodeURIComponent(String(relatedEntityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all current vocabularies related to a vocabulary, by its vocabulary id.
         * @param {number} vocabularyId The ID of the vocabulary for which to get the vocabularies related to it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabulariesRelatedToVocabularyById: async (vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('getVocabulariesRelatedToVocabularyById', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}/reverseRelatedVocabularies`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a current vocabulary by its id.
         * @param {number} vocabularyId The ID of the vocabulary to get.
         * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
         * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
         * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
         * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularyById: async (vocabularyId: number, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('getVocabularyById', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeVersions !== undefined) {
                localVarQueryParameter['includeVersions'] = includeVersions;
            }

            if (includeAccessPoints !== undefined) {
                localVarQueryParameter['includeAccessPoints'] = includeAccessPoints;
            }

            if (includeRelatedEntitiesAndVocabularies !== undefined) {
                localVarQueryParameter['includeRelatedEntitiesAndVocabularies'] = includeRelatedEntitiesAndVocabularies;
            }

            if (includeLanguageList !== undefined) {
                localVarQueryParameter['includeLanguageList'] = includeLanguageList;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Access points that have source=SYSTEM are stripped out.
         * @summary Get a vocabulary by its id, for editing.
         * @param {number} vocabularyId The ID of the vocabulary to get for editing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularyByIdEdit: async (vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('getVocabularyByIdEdit', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}/edit`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a current vocabulary by its slug.
         * @param {string} slug The slug of the vocabulary to get.
         * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
         * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
         * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
         * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularyBySlug: async (slug: string, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getVocabularyBySlug', 'slug', slug)
            const localVarPath = `/api/resource/vocabulariesBySlug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeVersions !== undefined) {
                localVarQueryParameter['includeVersions'] = includeVersions;
            }

            if (includeAccessPoints !== undefined) {
                localVarQueryParameter['includeAccessPoints'] = includeAccessPoints;
            }

            if (includeRelatedEntitiesAndVocabularies !== undefined) {
                localVarQueryParameter['includeRelatedEntitiesAndVocabularies'] = includeRelatedEntitiesAndVocabularies;
            }

            if (includeLanguageList !== undefined) {
                localVarQueryParameter['includeLanguageList'] = includeLanguageList;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns true, if the version has a draft instance. Returns false, if there is no draft instance with that version id. The result is returned in the booleanValue property.
         * @summary Determine if a version has a draft instance.
         * @param {number} versionId The ID of the version to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDraftVersionById: async (versionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('hasDraftVersionById', 'versionId', versionId)
            const localVarPath = `/api/resource/versions/{versionId}/hasDraft`
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns true, if the vocabulary has a draft instance, and the user is authorized to access it. Returns false in every other case, i.e., if there is no draft instance with that vocabulary id, or even if there is such a draft instance, but the user is not authorized to access it. The result is returned in the booleanValue property.
         * @summary Determine if a vocabulary has a draft instance.
         * @param {number} vocabularyId The ID of the vocabulary to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDraftVocabularyById: async (vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('hasDraftVocabularyById', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}/hasDraft`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query if the user has authorization to modify a current vocabulary. A Boolean result will be returned.
         * @param {number} vocabularyId The ID of the vocabulary to check ownership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ownsVocabularyById: async (vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('ownsVocabularyById', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}/owns`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a related entity.
         * @param {number} relatedEntityId The ID of the related entity to be updated.
         * @param {RelatedEntity} body The new value of the related entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelatedEntity: async (relatedEntityId: number, body: RelatedEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relatedEntityId' is not null or undefined
            assertParamExists('updateRelatedEntity', 'relatedEntityId', relatedEntityId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRelatedEntity', 'body', body)
            const localVarPath = `/api/resource/relatedEntities/{relatedEntityId}`
                .replace(`{${"relatedEntityId"}}`, encodeURIComponent(String(relatedEntityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/xml';
            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be updated.
         * @param {Vocabulary} body The vocabulary to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVocabulary: async (vocabularyId: number, body: Vocabulary, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('updateVocabulary', 'vocabularyId', vocabularyId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateVocabulary', 'body', body)
            const localVarPath = `/api/resource/vocabularies/{vocabularyId}`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/xml';
            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new related entity.
         * @param {RelatedEntity} body The related entity to be added.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelatedEntity(body: RelatedEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelatedEntity(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.createRelatedEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  The response contains the ID of the resulting upload in the integerValue field, and the sanitized filename in the stringValue field.
         * @summary Upload a file.
         * @param {string} owner The owner of the upload
         * @param {string} format The type of the upload
         * @param {File} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpload(owner: string, format: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUpload(owner, format, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.createUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new vocabulary.
         * @param {Vocabulary} body The vocabulary to be added.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVocabulary(body: Vocabulary, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vocabulary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVocabulary(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.createVocabulary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a related entity.
         * @param {number} relatedEntityId The ID of the related entity to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelatedEntity(relatedEntityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelatedEntity(relatedEntityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.deleteRelatedEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be deleted.
         * @param {boolean} [deleteCurrent] Whether or not to delete the current version.
         * @param {boolean} [deleteDraft] Whether or not to delete the draft version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVocabulary(vocabularyId: number, deleteCurrent?: boolean, deleteDraft?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVocabulary(vocabularyId, deleteCurrent, deleteDraft, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.deleteVocabulary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * In this version of the download method, a download format is specified as a query parameter. The response will include a Content-Disposition header that specifies a full filename based on the underlying data; its extension may be different from the value of the format query parameter.
         * @summary Get a download.
         * @param {number} downloadId The Id of the download.
         * @param {string} [format] The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(downloadId: number, format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(downloadId, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.download']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * In this version of the download method, the last component of the URL specifies a filename and an extension. The response will include a Content-Disposition header that specifies a filename and extension based on the underlying data; they may be different from the values specified.
         * @summary Get a download.
         * @param {number} downloadId The Id of the download.
         * @param {string} filename The filename of the download.
         * @param {string} extension The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadWithFilename(downloadId: number, filename: string, extension: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadWithFilename(downloadId, filename, extension, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.downloadWithFilename']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current access points of a version, by its version id.
         * @param {number} versionId The ID of the version from which to get the current access points.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessPointsForVersionById(versionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPointList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessPointsForVersionById(versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getAccessPointsForVersionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The result list contains one element for each vocabulary owned by the caller. The status attribute will be \"draft\" if there is only a draft instance of the vocabulary; in this case, hasDraft will be true. Otherwise, status will be either \"published\" or \"deprecated\", and hasDraft will be true if there is also a draft instance.
         * @summary Get a list of vocabularies owned by the caller.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnedVocabularies(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OwnedVocabularyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnedVocabularies(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getOwnedVocabularies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all current related entities, optionally, filtered by related entity type. Results do not include related entity identifiers.
         * @param {GetRelatedEntitiesRelatedEntityTypeEnum} [relatedEntityType] The type of the related entities to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedEntities(relatedEntityType?: GetRelatedEntitiesRelatedEntityTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedEntityList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedEntities(relatedEntityType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getRelatedEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current related entities of a vocabulary, by its vocabulary id.
         * @param {number} vocabularyId The ID of the vocabulary from which to get the current related entities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedEntitiesForVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedEntityList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedEntitiesForVocabularyById(vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getRelatedEntitiesForVocabularyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a current related entity by its id.
         * @param {number} relatedEntityId The ID of the related entity to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedEntityById(relatedEntityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedEntityById(relatedEntityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getRelatedEntityById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current concept tree of a version, by its version id.
         * @param {number} versionId The ID of the version from which to get the concept tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionArtefactConceptTree(versionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionArtefactConceptTree(versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVersionArtefactConceptTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current version artefacts of a version, by its version id. Results can be filtered by version artefact type.
         * @param {number} versionId The ID of the version from which to get the version artefacts.
         * @param {GetVersionArtefactsTypeEnum} [type] Version artefact type used to filter results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionArtefacts(versionId: number, type?: GetVersionArtefactsTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionArtefactList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionArtefacts(versionId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVersionArtefacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a current version by its id.
         * @param {number} versionId The ID of the version to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionById(versionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionById(versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVersionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current versions of a vocabulary, by its vocabulary id. The results are returned in reverse order of release date.
         * @param {number} vocabularyId The ID of the vocabulary from which to get the current versions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionsForVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionsForVocabularyById(vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVersionsForVocabularyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all the current vocabularies. This includes both published and deprecated vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVocabularies(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabularyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVocabularies(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVocabularies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all current vocabularies related to a related entity, by the related entity\'s id.
         * @param {number} relatedEntityId The ID of the related entity for which to get the vocabularies related to it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVocabulariesRelatedToRelatedEntityById(relatedEntityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseRelatedVocabularyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVocabulariesRelatedToRelatedEntityById(relatedEntityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVocabulariesRelatedToRelatedEntityById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all current vocabularies related to a vocabulary, by its vocabulary id.
         * @param {number} vocabularyId The ID of the vocabulary for which to get the vocabularies related to it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVocabulariesRelatedToVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseRelatedVocabularyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVocabulariesRelatedToVocabularyById(vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVocabulariesRelatedToVocabularyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a current vocabulary by its id.
         * @param {number} vocabularyId The ID of the vocabulary to get.
         * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
         * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
         * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
         * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVocabularyById(vocabularyId: number, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vocabulary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVocabularyById(vocabularyId, includeVersions, includeAccessPoints, includeRelatedEntitiesAndVocabularies, includeLanguageList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVocabularyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Access points that have source=SYSTEM are stripped out.
         * @summary Get a vocabulary by its id, for editing.
         * @param {number} vocabularyId The ID of the vocabulary to get for editing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVocabularyByIdEdit(vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vocabulary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVocabularyByIdEdit(vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVocabularyByIdEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a current vocabulary by its slug.
         * @param {string} slug The slug of the vocabulary to get.
         * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
         * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
         * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
         * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVocabularyBySlug(slug: string, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vocabulary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVocabularyBySlug(slug, includeVersions, includeAccessPoints, includeRelatedEntitiesAndVocabularies, includeLanguageList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getVocabularyBySlug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns true, if the version has a draft instance. Returns false, if there is no draft instance with that version id. The result is returned in the booleanValue property.
         * @summary Determine if a version has a draft instance.
         * @param {number} versionId The ID of the version to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasDraftVersionById(versionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasDraftVersionById(versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.hasDraftVersionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns true, if the vocabulary has a draft instance, and the user is authorized to access it. Returns false in every other case, i.e., if there is no draft instance with that vocabulary id, or even if there is such a draft instance, but the user is not authorized to access it. The result is returned in the booleanValue property.
         * @summary Determine if a vocabulary has a draft instance.
         * @param {number} vocabularyId The ID of the vocabulary to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasDraftVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasDraftVocabularyById(vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.hasDraftVocabularyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query if the user has authorization to modify a current vocabulary. A Boolean result will be returned.
         * @param {number} vocabularyId The ID of the vocabulary to check ownership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ownsVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ownsVocabularyById(vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.ownsVocabularyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a related entity.
         * @param {number} relatedEntityId The ID of the related entity to be updated.
         * @param {RelatedEntity} body The new value of the related entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRelatedEntity(relatedEntityId: number, body: RelatedEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRelatedEntity(relatedEntityId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.updateRelatedEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be updated.
         * @param {Vocabulary} body The vocabulary to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVocabulary(vocabularyId: number, body: Vocabulary, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vocabulary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVocabulary(vocabularyId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.updateVocabulary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new related entity.
         * @param {RelatedEntity} body The related entity to be added.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelatedEntity(body: RelatedEntity, options?: RawAxiosRequestConfig): AxiosPromise<RelatedEntity> {
            return localVarFp.createRelatedEntity(body, options).then((request) => request(axios, basePath));
        },
        /**
         *  The response contains the ID of the resulting upload in the integerValue field, and the sanitized filename in the stringValue field.
         * @summary Upload a file.
         * @param {string} owner The owner of the upload
         * @param {string} format The type of the upload
         * @param {File} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload(owner: string, format: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.createUpload(owner, format, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new vocabulary.
         * @param {Vocabulary} body The vocabulary to be added.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVocabulary(body: Vocabulary, options?: RawAxiosRequestConfig): AxiosPromise<Vocabulary> {
            return localVarFp.createVocabulary(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a related entity.
         * @param {number} relatedEntityId The ID of the related entity to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelatedEntity(relatedEntityId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRelatedEntity(relatedEntityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be deleted.
         * @param {boolean} [deleteCurrent] Whether or not to delete the current version.
         * @param {boolean} [deleteDraft] Whether or not to delete the draft version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVocabulary(vocabularyId: number, deleteCurrent?: boolean, deleteDraft?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVocabulary(vocabularyId, deleteCurrent, deleteDraft, options).then((request) => request(axios, basePath));
        },
        /**
         * In this version of the download method, a download format is specified as a query parameter. The response will include a Content-Disposition header that specifies a full filename based on the underlying data; its extension may be different from the value of the format query parameter.
         * @summary Get a download.
         * @param {number} downloadId The Id of the download.
         * @param {string} [format] The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(downloadId: number, format?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.download(downloadId, format, options).then((request) => request(axios, basePath));
        },
        /**
         * In this version of the download method, the last component of the URL specifies a filename and an extension. The response will include a Content-Disposition header that specifies a filename and extension based on the underlying data; they may be different from the values specified.
         * @summary Get a download.
         * @param {number} downloadId The Id of the download.
         * @param {string} filename The filename of the download.
         * @param {string} extension The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWithFilename(downloadId: number, filename: string, extension: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadWithFilename(downloadId, filename, extension, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current access points of a version, by its version id.
         * @param {number} versionId The ID of the version from which to get the current access points.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessPointsForVersionById(versionId: number, options?: RawAxiosRequestConfig): AxiosPromise<AccessPointList> {
            return localVarFp.getAccessPointsForVersionById(versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * The result list contains one element for each vocabulary owned by the caller. The status attribute will be \"draft\" if there is only a draft instance of the vocabulary; in this case, hasDraft will be true. Otherwise, status will be either \"published\" or \"deprecated\", and hasDraft will be true if there is also a draft instance.
         * @summary Get a list of vocabularies owned by the caller.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnedVocabularies(options?: RawAxiosRequestConfig): AxiosPromise<OwnedVocabularyList> {
            return localVarFp.getOwnedVocabularies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all current related entities, optionally, filtered by related entity type. Results do not include related entity identifiers.
         * @param {GetRelatedEntitiesRelatedEntityTypeEnum} [relatedEntityType] The type of the related entities to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedEntities(relatedEntityType?: GetRelatedEntitiesRelatedEntityTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<RelatedEntityList> {
            return localVarFp.getRelatedEntities(relatedEntityType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current related entities of a vocabulary, by its vocabulary id.
         * @param {number} vocabularyId The ID of the vocabulary from which to get the current related entities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedEntitiesForVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<RelatedEntityList> {
            return localVarFp.getRelatedEntitiesForVocabularyById(vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a current related entity by its id.
         * @param {number} relatedEntityId The ID of the related entity to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedEntityById(relatedEntityId: number, options?: RawAxiosRequestConfig): AxiosPromise<RelatedEntity> {
            return localVarFp.getRelatedEntityById(relatedEntityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current concept tree of a version, by its version id.
         * @param {number} versionId The ID of the version from which to get the concept tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionArtefactConceptTree(versionId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getVersionArtefactConceptTree(versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current version artefacts of a version, by its version id. Results can be filtered by version artefact type.
         * @param {number} versionId The ID of the version from which to get the version artefacts.
         * @param {GetVersionArtefactsTypeEnum} [type] Version artefact type used to filter results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionArtefacts(versionId: number, type?: GetVersionArtefactsTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<VersionArtefactList> {
            return localVarFp.getVersionArtefacts(versionId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a current version by its id.
         * @param {number} versionId The ID of the version to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionById(versionId: number, options?: RawAxiosRequestConfig): AxiosPromise<Version> {
            return localVarFp.getVersionById(versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current versions of a vocabulary, by its vocabulary id. The results are returned in reverse order of release date.
         * @param {number} vocabularyId The ID of the vocabulary from which to get the current versions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsForVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<VersionList> {
            return localVarFp.getVersionsForVocabularyById(vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the current vocabularies. This includes both published and deprecated vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularies(options?: RawAxiosRequestConfig): AxiosPromise<VocabularyList> {
            return localVarFp.getVocabularies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all current vocabularies related to a related entity, by the related entity\'s id.
         * @param {number} relatedEntityId The ID of the related entity for which to get the vocabularies related to it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabulariesRelatedToRelatedEntityById(relatedEntityId: number, options?: RawAxiosRequestConfig): AxiosPromise<ReverseRelatedVocabularyList> {
            return localVarFp.getVocabulariesRelatedToRelatedEntityById(relatedEntityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all current vocabularies related to a vocabulary, by its vocabulary id.
         * @param {number} vocabularyId The ID of the vocabulary for which to get the vocabularies related to it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabulariesRelatedToVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<ReverseRelatedVocabularyList> {
            return localVarFp.getVocabulariesRelatedToVocabularyById(vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a current vocabulary by its id.
         * @param {number} vocabularyId The ID of the vocabulary to get.
         * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
         * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
         * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
         * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularyById(vocabularyId: number, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Vocabulary> {
            return localVarFp.getVocabularyById(vocabularyId, includeVersions, includeAccessPoints, includeRelatedEntitiesAndVocabularies, includeLanguageList, options).then((request) => request(axios, basePath));
        },
        /**
         * Access points that have source=SYSTEM are stripped out.
         * @summary Get a vocabulary by its id, for editing.
         * @param {number} vocabularyId The ID of the vocabulary to get for editing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularyByIdEdit(vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<Vocabulary> {
            return localVarFp.getVocabularyByIdEdit(vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a current vocabulary by its slug.
         * @param {string} slug The slug of the vocabulary to get.
         * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
         * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
         * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
         * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVocabularyBySlug(slug: string, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Vocabulary> {
            return localVarFp.getVocabularyBySlug(slug, includeVersions, includeAccessPoints, includeRelatedEntitiesAndVocabularies, includeLanguageList, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns true, if the version has a draft instance. Returns false, if there is no draft instance with that version id. The result is returned in the booleanValue property.
         * @summary Determine if a version has a draft instance.
         * @param {number} versionId The ID of the version to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDraftVersionById(versionId: number, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.hasDraftVersionById(versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns true, if the vocabulary has a draft instance, and the user is authorized to access it. Returns false in every other case, i.e., if there is no draft instance with that vocabulary id, or even if there is such a draft instance, but the user is not authorized to access it. The result is returned in the booleanValue property.
         * @summary Determine if a vocabulary has a draft instance.
         * @param {number} vocabularyId The ID of the vocabulary to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDraftVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.hasDraftVocabularyById(vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query if the user has authorization to modify a current vocabulary. A Boolean result will be returned.
         * @param {number} vocabularyId The ID of the vocabulary to check ownership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ownsVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.ownsVocabularyById(vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a related entity.
         * @param {number} relatedEntityId The ID of the related entity to be updated.
         * @param {RelatedEntity} body The new value of the related entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelatedEntity(relatedEntityId: number, body: RelatedEntity, options?: RawAxiosRequestConfig): AxiosPromise<RelatedEntity> {
            return localVarFp.updateRelatedEntity(relatedEntityId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be updated.
         * @param {Vocabulary} body The vocabulary to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVocabulary(vocabularyId: number, body: Vocabulary, options?: RawAxiosRequestConfig): AxiosPromise<Vocabulary> {
            return localVarFp.updateVocabulary(vocabularyId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 */
export class ResourcesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new related entity.
     * @param {RelatedEntity} body The related entity to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRelatedEntity(body: RelatedEntity, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).createRelatedEntity(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The response contains the ID of the resulting upload in the integerValue field, and the sanitized filename in the stringValue field.
     * @summary Upload a file.
     * @param {string} owner The owner of the upload
     * @param {string} format The type of the upload
     * @param {File} file The file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUpload(owner: string, format: string, file: File, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).createUpload(owner, format, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new vocabulary.
     * @param {Vocabulary} body The vocabulary to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createVocabulary(body: Vocabulary, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).createVocabulary(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a related entity.
     * @param {number} relatedEntityId The ID of the related entity to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRelatedEntity(relatedEntityId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).deleteRelatedEntity(relatedEntityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vocabulary.
     * @param {number} vocabularyId The ID of the vocabulary to be deleted.
     * @param {boolean} [deleteCurrent] Whether or not to delete the current version.
     * @param {boolean} [deleteDraft] Whether or not to delete the draft version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteVocabulary(vocabularyId: number, deleteCurrent?: boolean, deleteDraft?: boolean, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).deleteVocabulary(vocabularyId, deleteCurrent, deleteDraft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In this version of the download method, a download format is specified as a query parameter. The response will include a Content-Disposition header that specifies a full filename based on the underlying data; its extension may be different from the value of the format query parameter.
     * @summary Get a download.
     * @param {number} downloadId The Id of the download.
     * @param {string} [format] The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public download(downloadId: number, format?: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).download(downloadId, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In this version of the download method, the last component of the URL specifies a filename and an extension. The response will include a Content-Disposition header that specifies a filename and extension based on the underlying data; they may be different from the values specified.
     * @summary Get a download.
     * @param {number} downloadId The Id of the download.
     * @param {string} filename The filename of the download.
     * @param {string} extension The format of the download. This must be a filename extension without the period, e.g., \&quot;rdf\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadWithFilename(downloadId: number, filename: string, extension: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).downloadWithFilename(downloadId, filename, extension, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current access points of a version, by its version id.
     * @param {number} versionId The ID of the version from which to get the current access points.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccessPointsForVersionById(versionId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getAccessPointsForVersionById(versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The result list contains one element for each vocabulary owned by the caller. The status attribute will be \"draft\" if there is only a draft instance of the vocabulary; in this case, hasDraft will be true. Otherwise, status will be either \"published\" or \"deprecated\", and hasDraft will be true if there is also a draft instance.
     * @summary Get a list of vocabularies owned by the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOwnedVocabularies(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getOwnedVocabularies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all current related entities, optionally, filtered by related entity type. Results do not include related entity identifiers.
     * @param {GetRelatedEntitiesRelatedEntityTypeEnum} [relatedEntityType] The type of the related entities to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRelatedEntities(relatedEntityType?: GetRelatedEntitiesRelatedEntityTypeEnum, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getRelatedEntities(relatedEntityType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current related entities of a vocabulary, by its vocabulary id.
     * @param {number} vocabularyId The ID of the vocabulary from which to get the current related entities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRelatedEntitiesForVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getRelatedEntitiesForVocabularyById(vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a current related entity by its id.
     * @param {number} relatedEntityId The ID of the related entity to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRelatedEntityById(relatedEntityId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getRelatedEntityById(relatedEntityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current concept tree of a version, by its version id.
     * @param {number} versionId The ID of the version from which to get the concept tree.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVersionArtefactConceptTree(versionId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVersionArtefactConceptTree(versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current version artefacts of a version, by its version id. Results can be filtered by version artefact type.
     * @param {number} versionId The ID of the version from which to get the version artefacts.
     * @param {GetVersionArtefactsTypeEnum} [type] Version artefact type used to filter results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVersionArtefacts(versionId: number, type?: GetVersionArtefactsTypeEnum, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVersionArtefacts(versionId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a current version by its id.
     * @param {number} versionId The ID of the version to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVersionById(versionId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVersionById(versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current versions of a vocabulary, by its vocabulary id. The results are returned in reverse order of release date.
     * @param {number} vocabularyId The ID of the vocabulary from which to get the current versions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVersionsForVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVersionsForVocabularyById(vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the current vocabularies. This includes both published and deprecated vocabularies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVocabularies(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVocabularies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all current vocabularies related to a related entity, by the related entity\'s id.
     * @param {number} relatedEntityId The ID of the related entity for which to get the vocabularies related to it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVocabulariesRelatedToRelatedEntityById(relatedEntityId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVocabulariesRelatedToRelatedEntityById(relatedEntityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all current vocabularies related to a vocabulary, by its vocabulary id.
     * @param {number} vocabularyId The ID of the vocabulary for which to get the vocabularies related to it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVocabulariesRelatedToVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVocabulariesRelatedToVocabularyById(vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a current vocabulary by its id.
     * @param {number} vocabularyId The ID of the vocabulary to get.
     * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
     * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
     * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
     * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVocabularyById(vocabularyId: number, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVocabularyById(vocabularyId, includeVersions, includeAccessPoints, includeRelatedEntitiesAndVocabularies, includeLanguageList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Access points that have source=SYSTEM are stripped out.
     * @summary Get a vocabulary by its id, for editing.
     * @param {number} vocabularyId The ID of the vocabulary to get for editing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVocabularyByIdEdit(vocabularyId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVocabularyByIdEdit(vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a current vocabulary by its slug.
     * @param {string} slug The slug of the vocabulary to get.
     * @param {boolean} [includeVersions] Whether or not to include version elements. If enabled, versions are returned in reverse order of release date.
     * @param {boolean} [includeAccessPoints] Whether or not to include access points. Setting this to true forces includeVersions also to be true.
     * @param {boolean} [includeRelatedEntitiesAndVocabularies] Whether or not to include full details of related entities, and top-level details of related vocabularies. If false (the default), only references will be included.
     * @param {boolean} [includeLanguageList] Whether or not to include descriptions of the language tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVocabularyBySlug(slug: string, includeVersions?: boolean, includeAccessPoints?: boolean, includeRelatedEntitiesAndVocabularies?: boolean, includeLanguageList?: boolean, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getVocabularyBySlug(slug, includeVersions, includeAccessPoints, includeRelatedEntitiesAndVocabularies, includeLanguageList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns true, if the version has a draft instance. Returns false, if there is no draft instance with that version id. The result is returned in the booleanValue property.
     * @summary Determine if a version has a draft instance.
     * @param {number} versionId The ID of the version to check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public hasDraftVersionById(versionId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).hasDraftVersionById(versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns true, if the vocabulary has a draft instance, and the user is authorized to access it. Returns false in every other case, i.e., if there is no draft instance with that vocabulary id, or even if there is such a draft instance, but the user is not authorized to access it. The result is returned in the booleanValue property.
     * @summary Determine if a vocabulary has a draft instance.
     * @param {number} vocabularyId The ID of the vocabulary to check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public hasDraftVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).hasDraftVocabularyById(vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query if the user has authorization to modify a current vocabulary. A Boolean result will be returned.
     * @param {number} vocabularyId The ID of the vocabulary to check ownership.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ownsVocabularyById(vocabularyId: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).ownsVocabularyById(vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a related entity.
     * @param {number} relatedEntityId The ID of the related entity to be updated.
     * @param {RelatedEntity} body The new value of the related entity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRelatedEntity(relatedEntityId: number, body: RelatedEntity, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).updateRelatedEntity(relatedEntityId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a vocabulary.
     * @param {number} vocabularyId The ID of the vocabulary to be updated.
     * @param {Vocabulary} body The vocabulary to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateVocabulary(vocabularyId: number, body: Vocabulary, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).updateVocabulary(vocabularyId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetRelatedEntitiesRelatedEntityTypeEnum = {
    Party: 'party',
    Service: 'service',
    Vocabulary: 'vocabulary'
} as const;
export type GetRelatedEntitiesRelatedEntityTypeEnum = typeof GetRelatedEntitiesRelatedEntityTypeEnum[keyof typeof GetRelatedEntitiesRelatedEntityTypeEnum];
export const GetVersionArtefactsTypeEnum = {
    ConceptList: 'conceptList',
    ConceptTree: 'conceptTree',
    HarvestPoolparty: 'harvestPoolparty',
    ResourceDocs: 'resourceDocs'
} as const;
export type GetVersionArtefactsTypeEnum = typeof GetVersionArtefactsTypeEnum[keyof typeof GetVersionArtefactsTypeEnum];


/**
 * ServicesApi - axios parameter creator
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an email subscription for an owner.
         * @param {string} owner Owner to subscribe to. Specify * to subscribe to notifications for all owners.
         * @param {string} emailAddress Subscriber email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSubscriptionOwner: async (owner: string, emailAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('createEmailSubscriptionOwner', 'owner', owner)
            // verify required parameter 'emailAddress' is not null or undefined
            assertParamExists('createEmailSubscriptionOwner', 'emailAddress', emailAddress)
            const localVarPath = `/api/services/subscriptions/email/owner/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an email subscription for the system.
         * @param {string} emailAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSubscriptionSystem: async (emailAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailAddress' is not null or undefined
            assertParamExists('createEmailSubscriptionSystem', 'emailAddress', emailAddress)
            const localVarPath = `/api/services/subscriptions/email/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an email subscription for a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be subscribed to.
         * @param {string} emailAddress Subscriber email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSubscriptionVocabulary: async (vocabularyId: number, emailAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('createEmailSubscriptionVocabulary', 'vocabularyId', vocabularyId)
            // verify required parameter 'emailAddress' is not null or undefined
            assertParamExists('createEmailSubscriptionVocabulary', 'emailAddress', emailAddress)
            const localVarPath = `/api/services/subscriptions/email/vocabularies/{vocabularyId}`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all email subscriptions for a subscriber.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionAll: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteEmailSubscriptionAll', 'token', token)
            const localVarPath = `/api/services/subscriptions/email/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an email subscription for an owner.
         * @param {string} token Subscriber authentication token
         * @param {string} owner Owner to unsubscribe from. Specify * to remove a subscription to notifications for all owners (in which case, any other existing subscriptions to individual owners will remain).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionOwner: async (token: string, owner: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteEmailSubscriptionOwner', 'token', token)
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('deleteEmailSubscriptionOwner', 'owner', owner)
            const localVarPath = `/api/services/subscriptions/email/owner/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an email subscription for the system.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionSystem: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteEmailSubscriptionSystem', 'token', token)
            const localVarPath = `/api/services/subscriptions/email/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an email subscription for a vocabulary.
         * @param {string} token Subscriber authentication token
         * @param {number} vocabularyId The ID of the vocabulary to be unsubscribed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionVocabulary: async (token: string, vocabularyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteEmailSubscriptionVocabulary', 'token', token)
            // verify required parameter 'vocabularyId' is not null or undefined
            assertParamExists('deleteEmailSubscriptionVocabulary', 'vocabularyId', vocabularyId)
            const localVarPath = `/api/services/subscriptions/email/vocabularies/{vocabularyId}`
                .replace(`{${"vocabularyId"}}`, encodeURIComponent(String(vocabularyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the email subscriptions for a subscriber.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSubscriptions: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getEmailSubscriptions', 'token', token)
            const localVarPath = `/api/services/subscriptions/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the metadata for a PoolParty project.
         * @param {number} serverId The PoolParty server Id.
         * @param {string} projectId The PoolParty project Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolPartyProjectMetadata: async (serverId: number, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('getPoolPartyProjectMetadata', 'serverId', serverId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPoolPartyProjectMetadata', 'projectId', projectId)
            const localVarPath = `/api/services/PoolParty/{serverId}/{projectId}/metadata`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of PoolParty projects.
         * @param {number} serverId The PoolParty server Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolPartyProjects: async (serverId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('getPoolPartyProjects', 'serverId', serverId)
            const localVarPath = `/api/services/PoolParty/{serverId}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the user\'s profile data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/userData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "ands_authentication", configuration)

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Because of standard web browser behaviour on receipt of redirects, it is not possible to use this method in the swagger-ui interface. On a successful redirect, you will either see no response, or the browser will follow the redirect.
         * @summary Perform a redirect.
         * @param {string} [mode] The mode of resolution. For now, only \&quot;current\&quot; is supported, and this is the default. 
         * @param {string} [iri] The IRI to be resolved.
         * @param {string} [suffix] An optional suffix to be appended to the redirected URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupIRI: async (mode?: string, iri?: string, suffix?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/services/resolve/lookupIRI`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (iri !== undefined) {
                localVarQueryParameter['iri'] = iri;
            }

            if (suffix !== undefined) {
                localVarQueryParameter['suffix'] = suffix;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform a search of vocabulary metadata.
         * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;widgetable\\\&quot;:true\\\&#39;: select only widgetable vocabularies. Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;access\\\&quot;, \\\&quot;format\\\&quot;, \\\&quot;language\\\&quot;, \\\&quot;licence\\\&quot;, \\\&quot;publisher\\\&quot;, \\\&quot;subject_labels\\\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (filtersJson: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersJson' is not null or undefined
            assertParamExists('search', 'filtersJson', filtersJson)
            const localVarPath = `/api/services/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (filtersJson !== undefined) { 
                localVarFormParams.set('filtersJson', filtersJson as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform a search of vocabulary resources.
         * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;collapse_expand\\\&quot;:false\\\&#39; disable collapse/expand results with the same IRI; \\\&#39;\\\&quot;language\\\&quot;:\\\&quot;[\\\&quot;NONE\\\&quot;,\\\&quot;en\\\&quot;]\\\&quot;\\\&#39;: limit to specified languages (to include results for all languages, don\\\&#39;t specify a value for this filter). Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;publisher\\\&quot;, \\\&quot;rdf_type\\\&quot;, \\\&quot;status\\\&quot;, \\\&quot;subject_labels\\\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResources: async (filtersJson: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filtersJson' is not null or undefined
            assertParamExists('searchResources', 'filtersJson', filtersJson)
            const localVarPath = `/api/services/search/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (filtersJson !== undefined) { 
                localVarFormParams.set('filtersJson', filtersJson as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an email subscription for an owner.
         * @param {string} owner Owner to subscribe to. Specify * to subscribe to notifications for all owners.
         * @param {string} emailAddress Subscriber email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmailSubscriptionOwner(owner: string, emailAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmailSubscriptionOwner(owner, emailAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.createEmailSubscriptionOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an email subscription for the system.
         * @param {string} emailAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmailSubscriptionSystem(emailAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmailSubscriptionSystem(emailAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.createEmailSubscriptionSystem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an email subscription for a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be subscribed to.
         * @param {string} emailAddress Subscriber email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmailSubscriptionVocabulary(vocabularyId: number, emailAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmailSubscriptionVocabulary(vocabularyId, emailAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.createEmailSubscriptionVocabulary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all email subscriptions for a subscriber.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmailSubscriptionAll(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmailSubscriptionAll(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.deleteEmailSubscriptionAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an email subscription for an owner.
         * @param {string} token Subscriber authentication token
         * @param {string} owner Owner to unsubscribe from. Specify * to remove a subscription to notifications for all owners (in which case, any other existing subscriptions to individual owners will remain).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmailSubscriptionOwner(token: string, owner: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmailSubscriptionOwner(token, owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.deleteEmailSubscriptionOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an email subscription for the system.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmailSubscriptionSystem(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmailSubscriptionSystem(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.deleteEmailSubscriptionSystem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an email subscription for a vocabulary.
         * @param {string} token Subscriber authentication token
         * @param {number} vocabularyId The ID of the vocabulary to be unsubscribed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmailSubscriptionVocabulary(token: string, vocabularyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmailSubscriptionVocabulary(token, vocabularyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.deleteEmailSubscriptionVocabulary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the email subscriptions for a subscriber.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmailSubscriptions(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmailSubscriptions(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.getEmailSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the metadata for a PoolParty project.
         * @param {number} serverId The PoolParty server Id.
         * @param {string} projectId The PoolParty project Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolPartyProjectMetadata(serverId: number, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolPartyProjectMetadata(serverId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.getPoolPartyProjectMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the list of PoolParty projects.
         * @param {number} serverId The PoolParty server Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolPartyProjects(serverId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolPartyProjects(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.getPoolPartyProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the user\'s profile data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.getUserData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Because of standard web browser behaviour on receipt of redirects, it is not possible to use this method in the swagger-ui interface. On a successful redirect, you will either see no response, or the browser will follow the redirect.
         * @summary Perform a redirect.
         * @param {string} [mode] The mode of resolution. For now, only \&quot;current\&quot; is supported, and this is the default. 
         * @param {string} [iri] The IRI to be resolved.
         * @param {string} [suffix] An optional suffix to be appended to the redirected URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupIRI(mode?: string, iri?: string, suffix?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupIRI(mode, iri, suffix, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.lookupIRI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Perform a search of vocabulary metadata.
         * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;widgetable\\\&quot;:true\\\&#39;: select only widgetable vocabularies. Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;access\\\&quot;, \\\&quot;format\\\&quot;, \\\&quot;language\\\&quot;, \\\&quot;licence\\\&quot;, \\\&quot;publisher\\\&quot;, \\\&quot;subject_labels\\\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(filtersJson: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(filtersJson, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Perform a search of vocabulary resources.
         * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;collapse_expand\\\&quot;:false\\\&#39; disable collapse/expand results with the same IRI; \\\&#39;\\\&quot;language\\\&quot;:\\\&quot;[\\\&quot;NONE\\\&quot;,\\\&quot;en\\\&quot;]\\\&quot;\\\&#39;: limit to specified languages (to include results for all languages, don\\\&#39;t specify a value for this filter). Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;publisher\\\&quot;, \\\&quot;rdf_type\\\&quot;, \\\&quot;status\\\&quot;, \\\&quot;subject_labels\\\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchResources(filtersJson: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchResources(filtersJson, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.searchResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServicesApi - factory interface
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an email subscription for an owner.
         * @param {string} owner Owner to subscribe to. Specify * to subscribe to notifications for all owners.
         * @param {string} emailAddress Subscriber email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSubscriptionOwner(owner: string, emailAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createEmailSubscriptionOwner(owner, emailAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an email subscription for the system.
         * @param {string} emailAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSubscriptionSystem(emailAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createEmailSubscriptionSystem(emailAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an email subscription for a vocabulary.
         * @param {number} vocabularyId The ID of the vocabulary to be subscribed to.
         * @param {string} emailAddress Subscriber email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSubscriptionVocabulary(vocabularyId: number, emailAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createEmailSubscriptionVocabulary(vocabularyId, emailAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all email subscriptions for a subscriber.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionAll(token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEmailSubscriptionAll(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an email subscription for an owner.
         * @param {string} token Subscriber authentication token
         * @param {string} owner Owner to unsubscribe from. Specify * to remove a subscription to notifications for all owners (in which case, any other existing subscriptions to individual owners will remain).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionOwner(token: string, owner: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEmailSubscriptionOwner(token, owner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an email subscription for the system.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionSystem(token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEmailSubscriptionSystem(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an email subscription for a vocabulary.
         * @param {string} token Subscriber authentication token
         * @param {number} vocabularyId The ID of the vocabulary to be unsubscribed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSubscriptionVocabulary(token: string, vocabularyId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEmailSubscriptionVocabulary(token, vocabularyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the email subscriptions for a subscriber.
         * @param {string} token Subscriber authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSubscriptions(token: string, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionList> {
            return localVarFp.getEmailSubscriptions(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the metadata for a PoolParty project.
         * @param {number} serverId The PoolParty server Id.
         * @param {string} projectId The PoolParty project Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolPartyProjectMetadata(serverId: number, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPoolPartyProjectMetadata(serverId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of PoolParty projects.
         * @param {number} serverId The PoolParty server Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolPartyProjects(serverId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPoolPartyProjects(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the user\'s profile data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserData(options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.getUserData(options).then((request) => request(axios, basePath));
        },
        /**
         * Because of standard web browser behaviour on receipt of redirects, it is not possible to use this method in the swagger-ui interface. On a successful redirect, you will either see no response, or the browser will follow the redirect.
         * @summary Perform a redirect.
         * @param {string} [mode] The mode of resolution. For now, only \&quot;current\&quot; is supported, and this is the default. 
         * @param {string} [iri] The IRI to be resolved.
         * @param {string} [suffix] An optional suffix to be appended to the redirected URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupIRI(mode?: string, iri?: string, suffix?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.lookupIRI(mode, iri, suffix, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform a search of vocabulary metadata.
         * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;widgetable\\\&quot;:true\\\&#39;: select only widgetable vocabularies. Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;access\\\&quot;, \\\&quot;format\\\&quot;, \\\&quot;language\\\&quot;, \\\&quot;licence\\\&quot;, \\\&quot;publisher\\\&quot;, \\\&quot;subject_labels\\\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(filtersJson: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.search(filtersJson, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform a search of vocabulary resources.
         * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;collapse_expand\\\&quot;:false\\\&#39; disable collapse/expand results with the same IRI; \\\&#39;\\\&quot;language\\\&quot;:\\\&quot;[\\\&quot;NONE\\\&quot;,\\\&quot;en\\\&quot;]\\\&quot;\\\&#39;: limit to specified languages (to include results for all languages, don\\\&#39;t specify a value for this filter). Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;publisher\\\&quot;, \\\&quot;rdf_type\\\&quot;, \\\&quot;status\\\&quot;, \\\&quot;subject_labels\\\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResources(filtersJson: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.searchResources(filtersJson, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServicesApi - object-oriented interface
 */
export class ServicesApi extends BaseAPI {
    /**
     * 
     * @summary Create an email subscription for an owner.
     * @param {string} owner Owner to subscribe to. Specify * to subscribe to notifications for all owners.
     * @param {string} emailAddress Subscriber email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEmailSubscriptionOwner(owner: string, emailAddress: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).createEmailSubscriptionOwner(owner, emailAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an email subscription for the system.
     * @param {string} emailAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEmailSubscriptionSystem(emailAddress: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).createEmailSubscriptionSystem(emailAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an email subscription for a vocabulary.
     * @param {number} vocabularyId The ID of the vocabulary to be subscribed to.
     * @param {string} emailAddress Subscriber email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEmailSubscriptionVocabulary(vocabularyId: number, emailAddress: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).createEmailSubscriptionVocabulary(vocabularyId, emailAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all email subscriptions for a subscriber.
     * @param {string} token Subscriber authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEmailSubscriptionAll(token: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).deleteEmailSubscriptionAll(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an email subscription for an owner.
     * @param {string} token Subscriber authentication token
     * @param {string} owner Owner to unsubscribe from. Specify * to remove a subscription to notifications for all owners (in which case, any other existing subscriptions to individual owners will remain).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEmailSubscriptionOwner(token: string, owner: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).deleteEmailSubscriptionOwner(token, owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an email subscription for the system.
     * @param {string} token Subscriber authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEmailSubscriptionSystem(token: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).deleteEmailSubscriptionSystem(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an email subscription for a vocabulary.
     * @param {string} token Subscriber authentication token
     * @param {number} vocabularyId The ID of the vocabulary to be unsubscribed from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEmailSubscriptionVocabulary(token: string, vocabularyId: number, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).deleteEmailSubscriptionVocabulary(token, vocabularyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the email subscriptions for a subscriber.
     * @param {string} token Subscriber authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEmailSubscriptions(token: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).getEmailSubscriptions(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the metadata for a PoolParty project.
     * @param {number} serverId The PoolParty server Id.
     * @param {string} projectId The PoolParty project Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPoolPartyProjectMetadata(serverId: number, projectId: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).getPoolPartyProjectMetadata(serverId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of PoolParty projects.
     * @param {number} serverId The PoolParty server Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPoolPartyProjects(serverId: number, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).getPoolPartyProjects(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the user\'s profile data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserData(options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).getUserData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Because of standard web browser behaviour on receipt of redirects, it is not possible to use this method in the swagger-ui interface. On a successful redirect, you will either see no response, or the browser will follow the redirect.
     * @summary Perform a redirect.
     * @param {string} [mode] The mode of resolution. For now, only \&quot;current\&quot; is supported, and this is the default. 
     * @param {string} [iri] The IRI to be resolved.
     * @param {string} [suffix] An optional suffix to be appended to the redirected URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public lookupIRI(mode?: string, iri?: string, suffix?: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).lookupIRI(mode, iri, suffix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform a search of vocabulary metadata.
     * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;widgetable\\\&quot;:true\\\&#39;: select only widgetable vocabularies. Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;access\\\&quot;, \\\&quot;format\\\&quot;, \\\&quot;language\\\&quot;, \\\&quot;licence\\\&quot;, \\\&quot;publisher\\\&quot;, \\\&quot;subject_labels\\\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public search(filtersJson: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).search(filtersJson, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform a search of vocabulary resources.
     * @param {string} filtersJson Filters that define the search parameters. The filters are specified as a JSON object. Examples of keys/values supported: \\\&#39;\\\&quot;q\\\&quot;:\\\&quot;query term\\\&quot;\\\&#39;: query term; \\\&#39;\\\&quot;pp\\\&quot;:10\\\&#39; number of results per page;\\\&#39;\\\&quot;p\\\&quot;:3\\\&#39; page number of results; \\\&#39;\\\&quot;sort\\\&quot;:\\\&quot;zToA\\\&quot;\\\&#39;: sort order of results; \\\&#39;\\\&quot;collapse_expand\\\&quot;:false\\\&#39; disable collapse/expand results with the same IRI; \\\&#39;\\\&quot;language\\\&quot;:\\\&quot;[\\\&quot;NONE\\\&quot;,\\\&quot;en\\\&quot;]\\\&quot;\\\&#39;: limit to specified languages (to include results for all languages, don\\\&#39;t specify a value for this filter). Facets are also specified with filters: e.g., \\\&#39;\\\&quot;publisher\\\&quot;:\\\&quot;CSIRO\\\&quot;\\\&#39;. Supported facets: \\\&quot;publisher\\\&quot;, \\\&quot;rdf_type\\\&quot;, \\\&quot;status\\\&quot;, \\\&quot;subject_labels\\\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchResources(filtersJson: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).searchResources(filtersJson, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilitiesApi - axios parameter creator
 */
export const UtilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate a slug.
         * @param {string} input String from which the slug is generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSlug: async (input: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'input' is not null or undefined
            assertParamExists('generateSlug', 'input', input)
            const localVarPath = `/api/utilities/generateSlug`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input !== undefined) {
                localVarQueryParameter['input'] = input;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the tag is valid, the response will contain the canonical form of the tag, andits full description. If the tag is invalid, the response will contain the errors generated during parsing.
         * @summary Parse a BCP 47 language tag.
         * @param {string} tag Language tag to be parsed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseLanguageTag: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('parseLanguageTag', 'tag', tag)
            const localVarPath = `/api/utilities/languages/parseLanguageTag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The response contains a list element for every tag included in the input. For each invalid tag, the list element has no attributes.
         * @summary Parse several BCP 47 language tags.
         * @param {Array<string>} tags Language tags to be parsed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseLanguageTags: async (tags: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('parseLanguageTags', 'tags', tags)
            const localVarPath = `/api/utilities/languages/parseLanguageTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            localVarHeaderParameter['Accept'] = 'application/xml,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilitiesApi - functional programming interface
 */
export const UtilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate a slug.
         * @param {string} input String from which the slug is generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSlug(input: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSlug(input, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.generateSlug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If the tag is valid, the response will contain the canonical form of the tag, andits full description. If the tag is invalid, the response will contain the errors generated during parsing.
         * @summary Parse a BCP 47 language tag.
         * @param {string} tag Language tag to be parsed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseLanguageTag(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseLanguageTag(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.parseLanguageTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The response contains a list element for every tag included in the input. For each invalid tag, the list element has no attributes.
         * @summary Parse several BCP 47 language tags.
         * @param {Array<string>} tags Language tags to be parsed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseLanguageTags(tags: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseLanguageTags(tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.parseLanguageTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UtilitiesApi - factory interface
 */
export const UtilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate a slug.
         * @param {string} input String from which the slug is generated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSlug(input: string, options?: RawAxiosRequestConfig): AxiosPromise<Result> {
            return localVarFp.generateSlug(input, options).then((request) => request(axios, basePath));
        },
        /**
         * If the tag is valid, the response will contain the canonical form of the tag, andits full description. If the tag is invalid, the response will contain the errors generated during parsing.
         * @summary Parse a BCP 47 language tag.
         * @param {string} tag Language tag to be parsed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseLanguageTag(tag: string, options?: RawAxiosRequestConfig): AxiosPromise<LanguageDetails> {
            return localVarFp.parseLanguageTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * The response contains a list element for every tag included in the input. For each invalid tag, the list element has no attributes.
         * @summary Parse several BCP 47 language tags.
         * @param {Array<string>} tags Language tags to be parsed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseLanguageTags(tags: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<LanguageList> {
            return localVarFp.parseLanguageTags(tags, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilitiesApi - object-oriented interface
 */
export class UtilitiesApi extends BaseAPI {
    /**
     * 
     * @summary Generate a slug.
     * @param {string} input String from which the slug is generated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateSlug(input: string, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).generateSlug(input, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the tag is valid, the response will contain the canonical form of the tag, andits full description. If the tag is invalid, the response will contain the errors generated during parsing.
     * @summary Parse a BCP 47 language tag.
     * @param {string} tag Language tag to be parsed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parseLanguageTag(tag: string, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).parseLanguageTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The response contains a list element for every tag included in the input. For each invalid tag, the list element has no attributes.
     * @summary Parse several BCP 47 language tags.
     * @param {Array<string>} tags Language tags to be parsed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parseLanguageTags(tags: Array<string>, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).parseLanguageTags(tags, options).then((request) => request(this.axios, this.basePath));
    }
}


