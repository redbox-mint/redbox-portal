import * as path from 'path';
import * as fs from 'fs';
import { Generator, GeneratorOptions } from '../utils/generator';
import { RedboxPaths } from '../utils/paths';

export interface AngularServiceGeneratorOptions extends GeneratorOptions {
  app: string;
  name: string;
  methods?: string[];
  paths: RedboxPaths;
}

export class AngularServiceGenerator extends Generator {
  private app: string;
  private name: string;
  private methods: string[];
  private paths: RedboxPaths;

  constructor(options: AngularServiceGeneratorOptions) {
    super(options);
    this.app = options.app.toLowerCase();
    this.name = options.name.toLowerCase();
    this.methods = options.methods || [];
    this.paths = options.paths;
  }

  public async generate(): Promise<void> {
    const projectRoot = path.join(this.paths.angular, 'projects', 'researchdatabox', this.app);
    if (!fs.existsSync(projectRoot)) {
      throw new Error(`Angular app project not found at: ${projectRoot}`);
    }

    const serviceClassName = this.toClassName(this.name);
    const fileName = `${this.name}.service.ts`;
    const servicePath = path.join(projectRoot, 'src', 'app', fileName);

    const content = this.generateServiceContent(serviceClassName);
    this.writeFile(servicePath, content);
  }

  private generateServiceContent(serviceClassName: string): string {
    const className = `${serviceClassName}Service`;
    
    let methodsContent = '';
    if (this.methods.length > 0) {
      const methodInfos = this.methods.map(method => ({
        raw: method,
        identifier: this.toSafeMethodName(method)
      }));
      methodsContent = methodInfos.map(method => `
  /**
   * ${this.capitalize(method.identifier)}
   */
  public async ${method.identifier}(): Promise<any> {
    const url = \`\${this.brandingAndPortalUrl}/app/${this.app}/${method.raw}\`;
    const result$ = this.http.get(url, { ...this.reqOptsJsonBodyOnly, context: this.httpContext });
    return await firstValueFrom(result$);
  }
`).join('\n');
    }

    return `import { Injectable, Inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { APP_BASE_HREF } from '@angular/common';
import { HttpClientService, ConfigService, UtilityService } from '@researchdatabox/portal-ng-common';
import { firstValueFrom } from 'rxjs';

/**
 * ${serviceClassName} Service
 * 
 * Generated by ReDBox Hook Kit
 */
@Injectable({
  providedIn: 'root'
})
export class ${className} extends HttpClientService {

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Inject(APP_BASE_HREF) rootContext: string,
    @Inject(UtilityService) utilService: UtilityService,
    @Inject(ConfigService) configService: ConfigService
  ) {
    super(http, rootContext, utilService, configService);
  }

  public override async waitForInit(): Promise<any> {
    await super.waitForInit(); 
    this.enableCsrfHeader();
    return this;
  }
${methodsContent}
}
`;
  }

  private toClassName(name: string): string {
    return name.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('');
  }

  private capitalize(s: string): string {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }

  private isValidTsIdentifier(name: string): boolean {
    return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);
  }

  private toSafeMethodName(method: string): string {
    const trimmed = method.trim();
    if (!trimmed) {
      throw new Error('Method name cannot be empty.');
    }
    if (this.isValidTsIdentifier(trimmed)) {
      return trimmed;
    }

    const parts = trimmed.split(/[^A-Za-z0-9_$]+/).filter(Boolean);
    const camel = parts.map((part, index) => {
      const lower = part.toLowerCase();
      if (index === 0) return lower;
      return lower.charAt(0).toUpperCase() + lower.slice(1);
    }).join('');
    let candidate = camel || trimmed.replace(/[^A-Za-z0-9_$]/g, '');
    if (!candidate) {
      throw new Error(`Method name '${method}' cannot be converted to a valid identifier.`);
    }
    if (!/^[A-Za-z_$]/.test(candidate)) {
      candidate = `_${candidate}`;
    }
    if (!this.isValidTsIdentifier(candidate)) {
      throw new Error(`Method name '${method}' cannot be converted to a valid identifier.`);
    }
    console.warn(`  [WARN] Sanitized method name '${method}' to '${candidate}'.`);
    return candidate;
  }
}
